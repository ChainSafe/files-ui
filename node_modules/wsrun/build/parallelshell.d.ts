/// <reference types="node" />
/// <reference types="bluebird" />
/**
 * Remove me.
 */
import * as Promise from 'bluebird';
import { ChildProcess } from 'child_process';
export interface CmdOptions {
    rejectOnNonZeroExit: boolean;
    collectLogs: boolean;
    prefixer?: (basePath: string, pkg: string, line: string) => string;
    doneCriteria?: string;
    path: string;
}
export declare class CmdProcess {
    private cmd;
    private pkgName;
    private opts;
    cp: ChildProcess;
    private _closed;
    private _finished;
    private _exitCode;
    readonly finished: Promise<void>;
    readonly closed: Promise<number>;
    readonly exitCode: Promise<number>;
    readonly exitError: Promise<void>;
    doneCriteria?: RegExp;
    constructor(cmd: string, pkgName: string, opts: CmdOptions);
    start(): void;
    private autoPrefix(line);
    private _start(cmd);
}
import { PkgJson, Dict } from './workspace';
export interface GraphOptions {
    bin: string;
    fastExit: boolean;
    collectLogs: boolean;
    addPrefix: boolean;
    mode: 'parallel' | 'serial' | 'stages';
    recursive: boolean;
    doneCriteria: string | undefined;
    workspacePath: string;
    exclude: string[];
    excludeMissing: boolean;
    showReport: boolean;
}
export declare class RunGraph {
    pkgJsons: PkgJson[];
    opts: GraphOptions;
    pkgPaths: Dict<string>;
    private procmap;
    children: CmdProcess[];
    finishedAll: Promise<CmdProcess[]>;
    private jsonMap;
    private runList;
    private resultMap;
    private throat;
    prefixer: (basePath: string, pkg: string, line: string) => string;
    constructor(pkgJsons: PkgJson[], opts: GraphOptions, pkgPaths: Dict<string>);
    private closeAll;
    private lookupOrRun(cmd, pkg);
    private allDeps(pkg);
    detectCycles(): string[];
    private makeCmd(cmd, pkg);
    private runOne(cmd, pkg);
    private checkResultsAndReport(cmd, pkgs);
    run(cmd: string, pkgs?: string[]): Promise<boolean>;
}
