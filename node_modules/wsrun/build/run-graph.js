"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Bromise = require("bluebird");
const chalk_1 = require("chalk");
const enums_1 = require("./enums");
const lodash_1 = require("lodash");
const cmd_process_1 = require("./cmd-process");
const minimatch = require("minimatch");
const fix_paths_1 = require("./fix-paths");
let mkThroat = require('throat')(Bromise);
let passThrough = f => f();
class Prefixer {
    constructor(wspath) {
        this.wspath = wspath;
        this.currentName = '';
        this.prefixer = (basePath, pkg, line) => {
            let l = '';
            if (this.currentName != pkg)
                l += chalk_1.default.bold((this.currentName = pkg)) + '\n';
            l += ' | ' + this.processFilePaths(basePath, line);
            return l;
        };
    }
    processFilePaths(basePath, line) {
        return fix_paths_1.fixPaths(this.wspath, basePath, line);
    }
}
class RunGraph {
    constructor(pkgJsons, opts, pkgPaths) {
        this.pkgJsons = pkgJsons;
        this.opts = opts;
        this.pkgPaths = pkgPaths;
        this.procmap = new Map();
        this.jsonMap = new Map();
        this.runList = new Set();
        this.resultMap = new Map();
        this.throat = passThrough;
        this.prefixer = new Prefixer(this.opts.workspacePath).prefixer;
        this.closeAll = () => {
            console.log('Stopping', this.children.length, 'active children');
            this.children.forEach(ch => ch.stop());
        };
        this.checkResultsAndReport = this.checkResultsAndReport.bind(this);
        this.closeAll = this.closeAll.bind(this);
        pkgJsons.forEach(j => this.jsonMap.set(j.name, j));
        this.children = [];
        // serial always has a concurrency of 1
        if (this.opts.mode === 'serial')
            this.throat = mkThroat(1);
        // max 16 proc unless otherwise specified
        else if (this.opts.mode === 'stages')
            this.throat = mkThroat(opts.concurrency || 16);
        else if (opts.concurrency)
            this.throat = mkThroat(opts.concurrency);
        process.on('SIGINT', this.closeAll); // close all children on ctrl+c
    }
    lookupOrRun(cmd, pkg) {
        let proc = this.procmap.get(pkg);
        if (proc == null) {
            proc = Bromise.resolve().then(() => this.runOne(cmd, pkg));
            this.procmap.set(pkg, proc);
            return proc;
        }
        return proc;
    }
    allDeps(pkg) {
        let findMyDeps = lodash_1.uniq(Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.devDependencies || {}))).filter(d => this.jsonMap.has(d) && (this.opts.recursive || this.runList.has(d)));
        return findMyDeps;
    }
    detectCycles() {
        let topLevelPkgs = {};
        for (let key of this.jsonMap.keys()) {
            topLevelPkgs[key] = '*';
        }
        let top = { name: '$', dependencies: topLevelPkgs };
        let self = this;
        function deepCycle(json, pathLookup) {
            let newPathLookup = pathLookup.concat([json.name]);
            let index = pathLookup.indexOf(json.name);
            if (index >= 0) {
                return newPathLookup.slice(index);
            }
            let currentDeps = Object.keys(json.dependencies || {}).concat(Object.keys(json.devDependencies || {}));
            for (let name of currentDeps) {
                let d = self.jsonMap.get(name);
                if (!d)
                    continue;
                let res = deepCycle(d, newPathLookup);
                if (res.length)
                    return res;
            }
            return [];
        }
        let res = deepCycle(top, []);
        return res;
    }
    makeCmd(cmd) {
        return [this.opts.bin].concat(cmd);
    }
    runCondition(cmd, pkg) {
        let cmdLine = this.makeCmd(cmd.split(' '));
        const child = new cmd_process_1.CmdProcess(cmdLine, pkg, {
            rejectOnNonZeroExit: false,
            silent: true,
            collectLogs: this.opts.collectLogs,
            prefixer: this.opts.addPrefix ? this.prefixer : undefined,
            doneCriteria: this.opts.doneCriteria,
            path: this.pkgPaths[pkg]
        });
        let rres = child.exitCode.then(code => code === 0);
        child.start();
        return rres;
    }
    runOne(cmdArray, pkg) {
        let p = this.jsonMap.get(pkg);
        if (p == null)
            throw new Error('Unknown package: ' + pkg);
        let myDeps = Bromise.all(this.allDeps(p).map(d => this.lookupOrRun(cmdArray, d)));
        return myDeps.then(depsStatuses => {
            this.resultMap.set(pkg, enums_1.ResultSpecialValues.Pending);
            if (this.opts.exclude.indexOf(pkg) >= 0) {
                console.log(chalk_1.default.bold(pkg), 'in exclude list, skipping');
                this.resultMap.set(pkg, enums_1.ResultSpecialValues.Excluded);
                return Bromise.resolve(enums_1.ProcResolution.Excluded);
            }
            if (this.opts.excludeMissing && (!p || !p.scripts || !p.scripts[cmdArray[0]])) {
                console.log(chalk_1.default.bold(pkg), 'has no', cmdArray[0], 'script, skipping missing');
                this.resultMap.set(pkg, enums_1.ResultSpecialValues.MissingScript);
                return Bromise.resolve(enums_1.ProcResolution.Missing);
            }
            let ifCondtition = Bromise.resolve(true);
            if (this.opts.if &&
                (!this.opts.ifDependency || !depsStatuses.find(ds => ds === enums_1.ProcResolution.Normal))) {
                ifCondtition = this.runCondition(this.opts.if, pkg);
            }
            let child = ifCondtition.then(shouldExecute => {
                if (!shouldExecute) {
                    this.resultMap.set(pkg, enums_1.ResultSpecialValues.Excluded);
                    return Bromise.resolve({
                        status: enums_1.ProcResolution.Excluded,
                        process: null
                    });
                }
                let cmdLine = this.makeCmd(cmdArray);
                const child = new cmd_process_1.CmdProcess(cmdLine, pkg, {
                    rejectOnNonZeroExit: this.opts.fastExit,
                    collectLogs: this.opts.collectLogs,
                    prefixer: this.opts.addPrefix ? this.prefixer : undefined,
                    doneCriteria: this.opts.doneCriteria,
                    path: this.pkgPaths[pkg]
                });
                child.exitCode.then(code => this.resultMap.set(pkg, code));
                this.children.push(child);
                return Promise.resolve({ status: enums_1.ProcResolution.Normal, process: child });
            });
            return child.then(ch => {
                let processRun = this.throat(() => {
                    if (ch.process) {
                        ch.process.start();
                        return ch.process.finished;
                    }
                    return Bromise.resolve();
                });
                if (this.opts.mode === 'parallel' || !ch.process)
                    return ch.status;
                else
                    return processRun.thenReturn(enums_1.ProcResolution.Normal);
            });
        });
    }
    checkResultsAndReport(cmdLine, pkgs) {
        let cmd = cmdLine.join(' ');
        const pkgsInError = [];
        const pkgsSuccessful = [];
        const pkgsPending = [];
        const pkgsSkipped = [];
        const pkgsMissingScript = [];
        this.resultMap.forEach((result, pkg) => {
            switch (result) {
                case enums_1.ResultSpecialValues.Excluded:
                    pkgsSkipped.push(pkg);
                    break;
                case enums_1.ResultSpecialValues.MissingScript:
                    pkgsMissingScript.push(pkg);
                    break;
                case enums_1.ResultSpecialValues.Pending:
                    pkgsPending.push(pkg);
                    break;
                case 0:
                    pkgsSuccessful.push(pkg);
                    break;
                default:
                    pkgsInError.push(pkg);
                    break;
            }
        });
        if (this.opts.showReport) {
            const formatPkgs = (pgks) => pgks.join(', ');
            const pkgsNotStarted = pkgs.filter(pkg => !this.resultMap.has(pkg));
            console.log(chalk_1.default.bold('\nReport:'));
            if (pkgsInError.length)
                console.log(chalk_1.default.red(`  ${pkgsInError.length} packages finished \`${cmd}\` with error: ${formatPkgs(pkgsInError)}`));
            if (pkgsSuccessful.length)
                console.log(chalk_1.default.green(`  ${pkgsSuccessful.length} packages finished \`${cmd}\` successfully: ${formatPkgs(pkgsSuccessful)}`));
            if (pkgsPending.length)
                console.log(chalk_1.default.white(`  ${pkgsPending.length} packages have been cancelled running \`${cmd}\`: ${formatPkgs(pkgsPending)}`));
            if (pkgsNotStarted.length)
                console.log(chalk_1.default.white(`  ${pkgsNotStarted.length} packages have not started running \`${cmd}\`: ${formatPkgs(pkgsNotStarted)}`));
            if (pkgsMissingScript.length)
                console.log(chalk_1.default.gray(`  ${pkgsMissingScript.length} packages are missing script \`${cmd}\`: ${formatPkgs(pkgsMissingScript)}`));
            if (pkgsSkipped.length)
                console.log(chalk_1.default.gray(`  ${pkgsSkipped.length} packages have been skipped: ${formatPkgs(pkgsSkipped)}`));
            console.log();
        }
        return pkgsInError.length > 0;
    }
    expandGlobs(globs) {
        return this.pkgJsons.map(p => p.name).filter(name => globs.some(glob => minimatch(name, glob)));
    }
    run(cmd, globs = ['**/*']) {
        let pkgs = this.expandGlobs(globs);
        this.runList = new Set(pkgs);
        return (Bromise.all(pkgs.map(pkg => this.lookupOrRun(cmd, pkg)))
            // Wait for any of them to error
            .then(() => Bromise.all(this.children.map(c => c.exitError)))
            // If any of them do, and fastExit is enabled, stop every other
            .catch(_err => this.opts.fastExit && this.closeAll())
            // Wait for the all the processes to finish
            .then(() => Bromise.all(this.children.map(c => c.result)))
            // Generate report
            .then(() => this.checkResultsAndReport(cmd, pkgs)));
    }
}
exports.RunGraph = RunGraph;
//# sourceMappingURL=run-graph.js.map