"use strict";
/**
 * Remove me.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Promise = require("bluebird");
const child_process_1 = require("child_process");
const originalSplit = require("split");
const chalk_1 = require("chalk");
const path = require("path");
let mkThroat = require('throat')(Promise);
let passThrough = f => f();
let MaxPrefixLen = 15;
class Prefixer {
    constructor(wspath) {
        this.wspath = wspath;
        this.currentName = '';
        this.prefixer = (basePath, pkg, line) => {
            let l = '';
            if (this.currentName != pkg)
                l += chalk_1.default.bold((this.currentName = pkg)) + '\n';
            l += ' | ' + this.processFilePaths(basePath, line);
            return l;
        };
    }
    processFilePaths(basePath, line) {
        return line.replace(/(([^/\s'"*]+[/]){1,})([^/'"*]+)\.[0-9a-zA-Z]{1,6}/, m => path.relative(this.wspath, path.resolve(basePath, m)));
    }
}
function defer() {
    let d;
    let promise = new Promise((resolve, reject) => {
        d = { resolve, reject };
    });
    d.promise = promise;
    return d;
}
const SPLIT_OPTIONS = { trailing: false };
const SPLIT_MAPPER = (x) => x;
const split = () => originalSplit(/\r?\n/, SPLIT_MAPPER, SPLIT_OPTIONS);
class CmdProcess {
    constructor(cmd, pkgName, opts) {
        this.cmd = cmd;
        this.pkgName = pkgName;
        this.opts = opts;
        this.pkgName = pkgName;
        this.opts = opts;
        this._finished = defer();
        this._exitCode = defer();
        this._closed = defer();
        if (this.opts.doneCriteria)
            this.doneCriteria = new RegExp(this.opts.doneCriteria);
    }
    get finished() {
        return this._finished.promise;
    }
    get closed() {
        return this._closed.promise;
    }
    get exitCode() {
        return this._exitCode.promise;
    }
    get exitError() {
        return this.exitCode.then(c => {
            if (c != 0)
                throw new Error('`' + this.cmd + '` failed with exit code ' + c);
        });
    }
    start() {
        this._start(this.cmd);
        this.cp.once('close', code => {
            this._closed.resolve(code);
            this._exitCode.resolve(code);
        });
        this.cp.once('exit', code => this._exitCode.resolve(code));
        this.exitCode.then(code => {
            if (code > 0) {
                const msg = '`' + this.cmd + '` failed with exit code ' + code;
                console.error(msg);
                if (this.opts.rejectOnNonZeroExit)
                    return this._finished.reject(new Error(msg));
            }
            this._finished.resolve();
        });
    }
    autoPrefix(line) {
        return this.opts.prefixer ? this.opts.prefixer(this.opts.path, this.pkgName, line) : line;
    }
    _start(cmd) {
        let sh;
        let args;
        // cross platform compatibility
        if (process.platform === 'win32') {
            sh = 'cmd';
            args = ['/c', cmd];
        }
        else {
            ;
            [sh, ...args] = cmd.split(' ');
            //sh = 'bash'
            //shFlag = '-c'
        }
        const stdOutBuffer = [];
        const stdErrBuffer = [];
        this.cmd = cmd;
        this.cp = child_process_1.spawn(sh, args, {
            cwd: this.opts.path ||
                (process.versions.node < '8.0.0' ? process.cwd : process.cwd()),
            env: Object.assign(process.env, { FORCE_COLOR: process.stdout.isTTY }),
            stdio: this.opts.collectLogs || this.opts.prefixer != null || this.opts.doneCriteria
                ? 'pipe'
                : 'inherit'
        });
        if (this.cp.stdout)
            this.cp.stdout.pipe(split()).on('data', (line) => {
                if (this.opts.collectLogs)
                    stdOutBuffer.push(line);
                else
                    console.log(this.autoPrefix(line));
                if (this.doneCriteria && this.doneCriteria.test(line))
                    this._finished.resolve();
            });
        if (this.cp.stderr)
            this.cp.stderr.pipe(split()).on('data', (line) => {
                if (this.opts.collectLogs)
                    stdErrBuffer.push(line);
                else
                    console.error(this.autoPrefix(line));
                if (this.doneCriteria && this.doneCriteria.test(line))
                    this._finished.resolve();
            });
        if (this.opts.collectLogs)
            this.closed.then(() => {
                console.log(stdOutBuffer.map(line => this.autoPrefix(line)).join('\n'));
                console.error(stdErrBuffer.map(line => this.autoPrefix(line)).join('\n'));
            });
    }
}
exports.CmdProcess = CmdProcess;
const lodash_1 = require("lodash");
var ResultSpecialValues;
(function (ResultSpecialValues) {
    ResultSpecialValues["Pending"] = "PENDING";
    ResultSpecialValues["Excluded"] = "EXCLUDED";
    ResultSpecialValues["MissingScript"] = "MISSING_SCRIPT";
})(ResultSpecialValues || (ResultSpecialValues = {}));
class RunGraph {
    constructor(pkgJsons, opts, pkgPaths) {
        this.pkgJsons = pkgJsons;
        this.opts = opts;
        this.pkgPaths = pkgPaths;
        this.procmap = new Map();
        this.jsonMap = new Map();
        this.runList = new Set();
        this.resultMap = new Map();
        this.throat = passThrough;
        this.prefixer = new Prefixer(this.opts.workspacePath).prefixer;
        this.closeAll = () => {
            console.log('Stopping', this.children.length, 'active children');
            this.children.forEach(ch => {
                ch.cp.removeAllListeners('close');
                ch.cp.removeAllListeners('exit');
                ch.cp.kill('SIGINT');
            });
        };
        this.checkResultsAndReport = this.checkResultsAndReport.bind(this);
        this.closeAll = this.closeAll.bind(this);
        pkgJsons.forEach(j => this.jsonMap.set(j.name, j));
        this.children = [];
        if (this.opts.mode === 'serial')
            this.throat = mkThroat(1);
        if (this.opts.mode === 'stages')
            this.throat = mkThroat(16); // max 16 proc
        process.on('SIGINT', this.closeAll); // close all children on ctrl+c
    }
    lookupOrRun(cmd, pkg) {
        let proc = this.procmap.get(pkg);
        if (proc == null) {
            proc = Promise.resolve().then(() => this.runOne(cmd, pkg));
            this.procmap.set(pkg, proc);
        }
        return proc;
    }
    allDeps(pkg) {
        let findMyDeps = lodash_1.uniq(Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.devDependencies || {}))).filter(d => this.jsonMap.has(d) && (this.opts.recursive || this.runList.has(d)));
        return findMyDeps;
    }
    detectCycles() {
        let topLevelPkgs = {};
        for (let key of this.jsonMap.keys()) {
            topLevelPkgs[key] = '*';
        }
        let top = { name: '$', dependencies: topLevelPkgs };
        let self = this;
        function deepCycle(json, pathLookup) {
            let newPathLookup = pathLookup.concat([json.name]);
            let index = pathLookup.indexOf(json.name);
            if (index >= 0) {
                return newPathLookup.slice(index);
            }
            let currentDeps = Object.keys(json.dependencies || {}).concat(Object.keys(json.devDependencies || {}));
            for (let name of currentDeps) {
                let d = self.jsonMap.get(name);
                if (!d)
                    continue;
                let res = deepCycle(d, newPathLookup);
                if (res.length)
                    return res;
            }
            return [];
        }
        let res = deepCycle(top, []);
        return res;
    }
    makeCmd(cmd, pkg) {
        return `${this.opts.bin} ${cmd}`;
    }
    runOne(cmd, pkg) {
        let p = this.jsonMap.get(pkg);
        if (p == null)
            throw new Error('Unknown package: ' + pkg);
        let myDeps = Promise.all(this.allDeps(p).map(d => this.lookupOrRun(cmd, d)));
        return myDeps.then(() => {
            this.resultMap.set(pkg, ResultSpecialValues.Pending);
            if (this.opts.exclude.indexOf(pkg) >= 0) {
                console.log(chalk_1.default.bold(pkg), 'in exclude list, skipping');
                this.resultMap.set(pkg, ResultSpecialValues.Excluded);
                return Promise.resolve();
            }
            if (this.opts.excludeMissing && (!p || !p.scripts || !p.scripts[cmd])) {
                console.log(chalk_1.default.bold(pkg), 'has no ', cmd, 'script, skipping missing');
                this.resultMap.set(pkg, ResultSpecialValues.MissingScript);
                return Promise.resolve();
            }
            let cmdLine = this.makeCmd(cmd, pkg);
            const child = new CmdProcess(cmdLine, pkg, {
                rejectOnNonZeroExit: this.opts.fastExit,
                collectLogs: this.opts.collectLogs,
                prefixer: this.opts.addPrefix ? this.prefixer : undefined,
                doneCriteria: this.opts.doneCriteria,
                path: this.pkgPaths[pkg]
            });
            child.exitCode.then(code => this.resultMap.set(pkg, code));
            this.children.push(child);
            let finished = this.throat(() => {
                child.start();
                return child.finished;
            });
            if (this.opts.mode === 'parallel')
                finished = Promise.resolve();
            return finished;
        });
    }
    checkResultsAndReport(cmd, pkgs) {
        const pkgsInError = [];
        const pkgsSuccessful = [];
        const pkgsPending = [];
        const pkgsSkipped = [];
        const pkgsMissingScript = [];
        this.resultMap.forEach((result, pkg) => {
            switch (result) {
                case ResultSpecialValues.Excluded:
                    pkgsSkipped.push(pkg);
                    break;
                case ResultSpecialValues.MissingScript:
                    pkgsMissingScript.push(pkg);
                    break;
                case ResultSpecialValues.Pending:
                    pkgsPending.push(pkg);
                    break;
                case 0:
                    pkgsSuccessful.push(pkg);
                    break;
                default:
                    pkgsInError.push(pkg);
                    break;
            }
        });
        if (this.opts.showReport) {
            const formatPkgs = (pgks) => pgks.join(', ');
            const pkgsNotStarted = pkgs.filter(pkg => !this.resultMap.has(pkg));
            console.log(chalk_1.default.bold('\nReport:'));
            if (pkgsInError.length)
                console.log(chalk_1.default.red(`  ${pkgsInError.length} packages finished \`${cmd}\` with error: ${formatPkgs(pkgsInError)}`));
            if (pkgsSuccessful.length)
                console.log(chalk_1.default.green(`  ${pkgsSuccessful.length} packages finished \`${cmd}\` successfully: ${formatPkgs(pkgsSuccessful)}`));
            if (pkgsPending.length)
                console.log(chalk_1.default.white(`  ${pkgsPending.length} packages have been cancelled running \`${cmd}\`: ${formatPkgs(pkgsPending)}`));
            if (pkgsNotStarted.length)
                console.log(chalk_1.default.white(`  ${pkgsNotStarted.length} packages have not started running \`${cmd}\`: ${formatPkgs(pkgsNotStarted)}`));
            if (pkgsMissingScript.length)
                console.log(chalk_1.default.gray(`  ${pkgsMissingScript.length} packages are missing script \`${cmd}\`: ${formatPkgs(pkgsMissingScript)}`));
            if (pkgsSkipped.length)
                console.log(chalk_1.default.gray(`  ${pkgsSkipped.length} packages have been skipped: ${formatPkgs(pkgsSkipped)}`));
            console.log();
        }
        return pkgsInError.length > 0;
    }
    run(cmd, pkgs = this.pkgJsons.map(p => p.name)) {
        this.runList = new Set(pkgs);
        return Promise.all(pkgs.map(pkg => this.lookupOrRun(cmd, pkg)))
            .then(() => Promise.all(this.children.map(c => c.exitError)))
            .catch(err => this.opts.fastExit && this.closeAll())
            .then(() => this.checkResultsAndReport(cmd, pkgs));
    }
}
exports.RunGraph = RunGraph;
//# sourceMappingURL=parallelshell.js.map