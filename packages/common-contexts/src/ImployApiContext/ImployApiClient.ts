/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IImployApiClient {
  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  loginUser(body: Login): Promise<AccessRefreshTokens>
  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(body: UserSignUp): Promise<User>
  /**
   * Get User Data based on BearToken
   * @return successful operation
   */
  getUser(authorization: string): Promise<User>
  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updateUser(authorization: string, body: UserPatch): Promise<User>
  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(authorization: string): Promise<void>
  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  postNewEmailVerify(
    authorization: string,
    body: VerifyEmailToken,
  ): Promise<void>
  /**
   * put words here
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  getRefreshToken(token: string): Promise<AccessRefreshTokens>
  /**
   * put words here
   * @return Successful Operation
   */
  getWeb3Token(): Promise<Web3Login>
  /**
   * put words here
   * @param body (optional) words go here
   * @return Successful Operation
   */
  postWeb3Token(
    body?: Web3RequestToken | undefined,
  ): Promise<AccessRefreshTokens>
  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updatePassword(authorization: string, body: NewPassword): Promise<void>
  /**
   * Updates user info
   * @param email Email Address of the
   * @return Successful Operation
   */
  getResetPassword(email: string): Promise<void>
  /**
   * Complete the Password reset process
   * @param body Updated user object
   * @return Successful Operation
   */
  postPasswordReset(body: ResetPassword): Promise<void>
  /**
   * Complete a Password the Password reset process
   * @param body words go here
   * @return Successful Operation
   */
  postPasswordResetVerify(body: VerifyPasswordReset): Promise<void>
  /**
   * Creates a new project
   * @param body information about a project
   * @return Successful Operation
   */
  addproject(authorization: string, body: ProjectRequest): Promise<Project>
  /**
   * this operation soft deletes a project and no longer be visible to the user
   * @param id identification number of the project
   * @return Successful Operation
   */
  deleteproject(authorization: string, id: number): Promise<void>
  /**
   * put words here
   * @param id identification number of the project
   * @param body information about a project sent in a request
   * @return Successful Operation
   */
  updateproject(
    authorization: string,
    id: number,
    body: ProjectRequest,
  ): Promise<Project>
  /**
   * retrieves information about a specific project
   * @param id identification number of the project
   * @return Successful Operation
   */
  getProject(authorization: string, id: number): Promise<Project>
  /**
   * this operation retrieves all projects for a given user
   * @return an array of project objects
   */
  getallproject(authorization: string): Promise<Project[]>
  /**
   * Deploy a blockchain environment
   * @param body information about a project
   * @return an array of project objects
   */
  addDeployment(
    authorization: string,
    body: NewDeploymentRequest,
  ): Promise<Deployment>
  /**
   * this operation deprovisions a deployed blockchain environment in AWS
   * @param id identification number of the deployment
   * @return Successful Operation
   */
  deletedeployment(authorization: string, id: number): Promise<void>
  /**
   * this operation retuns the status of an active deployment
   * @param id identification number of the deployment
   * @return Successful Operation.  Valid values areCreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12, Unhealthy = 13
   */
  getdeploymentstatus(authorization: string, id: number): Promise<number>
  /**
   * this operation returns an array of actve deployments
   * @param id identification number of the deployment
   * @return an array of deployment objects
   */
  getdeployments(authorization: string, id: number): Promise<Deployment[]>
  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  addCard(authorization: string, body: AddCardRequest): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  updateDefaultCard(authorization: string, body: CardID): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  getDefaultCard(authorization: string): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  deleteCard(authorization: string, id: number): Promise<void>
  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getCard(authorization: string, id: number): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getAllCards(authorization: string): Promise<void>
  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/invoices/object
   */
  getAllInvoices(authorization: string): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getSubscription(authorization: string, id: number): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getAllSubscriptions(authorization: string): Promise<void>
  /**
   * upload a bunch of files to the pin service
   * @param file (optional)
   * @param path (optional)
   * @param replication (optional)
   * @param deal_duration (optional)
   * @return Successful Operation
   */
  uploadPins(
    authorization: string,
    file?: any | undefined,
    path?: string | undefined,
    replication?: number | undefined,
    deal_duration?: boolean | undefined,
  ): Promise<void>
  /**
   * get pin object info
   * @param pin_id pin object cid
   * @return Successful Operation,
   */
  getPinsByCID(authorization: string, pin_id: string): Promise<Anonymous2>
  /**
   * delete the pin object
   * @param pin_id pin object cid
   * @return Successful Operation
   */
  deletePins(authorization: string, pin_id: string): Promise<void>
  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  updatePin(authorization: string, pin_id: string, body: Body): Promise<void>
  /**
   * add pin objects
   * @param body words go here
   * @return Successful Operation
   */
  addPin(api_key: string, body: Body2): Promise<void>
  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  getAllPins(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
  ): Promise<Anonymous3[]>
  /**
   * retrieve asks
   * @return Successful Operation returns objects referenced here  https://github.com/textileio/powergate/blob/master/index/ask/types.go
   */
  getAsks(api_key: string): Promise<Anonymous4>
  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation returns a deal record object referenced here https://github.com/textileio/powergate/blob/master/deals/types.go
   */
  getDeals(
    api_key: string,
    direction: Direction,
    only?: Only | undefined,
  ): Promise<Anonymous5>
  /**
   * retrieve faults
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/faults/types.go
   */
  getFaults(authorization: string): Promise<Anonymous6>
  /**
   * retrieve miners
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getMiners(authorization: string): Promise<Anonymous7>
  /**
   * retrieve peers
   * @return Successful Operation returns objects referenced here hhttps://github.com/textileio/powergate/blob/master/net/interface.go
   */
  getPeers(authorization: string): Promise<Anonymous8>
  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getTopMiners(api_key: string, limit: number): Promise<Anonymous9>
  /**
   * returns file store info
   * @return Successful Operation
   */
  getFileStoreInfo(authorization: string): Promise<Anonymous10>
  /**
   * retrieve file content
   * @param body file path
   * @return Successful Operation
   */
  getFileContent(authorization: string, body: FileRequest): Promise<void>
  /**
   * uploads a file
   * @param file (optional)
   * @param path (optional)
   * @param type (optional)
   * @param update (optional)
   * @return Successful Operation
   */
  addFile(
    authorization: string,
    file?: string | undefined,
    path?: string | undefined,
    type?: string | undefined,
    update?: boolean | undefined,
  ): Promise<AddFileResponse>
  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveObject(authorization: string, body: FileRequest): Promise<void>
  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getFileInfo(authorization: string, body: FileRequest): Promise<void>
  /**
   * removes a file or empty directory
   * @param body file path
   * @return Successful Operation
   */
  removeObject(authorization: string, body: FileRequest): Promise<void>
  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getChildList(authorization: string, body: FileRequest): Promise<void>
  /**
   * creates new directory
   * @param body file path
   * @return Successful Operation
   */
  addDirectory(authorization: string, body: FileRequest): Promise<void>
}

export class ImployApiClient implements IImployApiClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>
  }
  private baseUrl: string
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window
    this.baseUrl = baseUrl ? baseUrl : "https://stage.api.chainsafe.site"
  }

  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  loginUser(body: Login): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLoginUser(_response)
    })
  }

  protected processLoginUser(response: Response): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <AccessRefreshTokens>(
                JSON.parse(_responseText, this.jsonParseReviver)
              )
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid username/password supplied",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(body: UserSignUp): Promise<User> {
    let url_ = this.baseUrl + "/user/signup"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignup(_response)
    })
  }

  protected processSignup(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <User>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Bad Request Binding",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Bad Request Password Not Matching",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Bad Request Email Already Exists",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Get User Data based on BearToken
   * @return successful operation
   */
  getUser(authorization: string): Promise<User> {
    let url_ = this.baseUrl + "/user"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetUser(_response)
    })
  }

  protected processGetUser(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <User>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updateUser(authorization: string, body: UserPatch): Promise<User> {
    let url_ = this.baseUrl + "/user"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "PATCH",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateUser(_response)
    })
  }

  protected processUpdateUser(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <User>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Email Verification sent recently",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else if (status === 412) {
      return response.text().then((_responseText) => {
        let result412: any = null
        result412 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "User with this email, phone number or username already exists",
          status,
          _responseText,
          _headers,
          result412,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(authorization: string): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetEmailVerify(_response)
    })
  }

  protected processGetEmailVerify(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Email already verified",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Email sent recently",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  postNewEmailVerify(
    authorization: string,
    body: VerifyEmailToken,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostNewEmailVerify(_response)
    })
  }

  protected processPostNewEmailVerify(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 412) {
      return response.text().then((_responseText) => {
        let result412: any = null
        result412 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Confirmation or reset token expired",
          status,
          _responseText,
          _headers,
          result412,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Email already verified",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Confirmation or reset token is invalid",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * put words here
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  getRefreshToken(token: string): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/refresh/{token}"
    if (token === undefined || token === null)
      throw new Error("The parameter 'token' must be defined.")
    url_ = url_.replace("{token}", encodeURIComponent("" + token))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRefreshToken(_response)
    })
  }

  protected processGetRefreshToken(
    response: Response,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <AccessRefreshTokens>(
                JSON.parse(_responseText, this.jsonParseReviver)
              )
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Confirmation or reset token is invalid",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * put words here
   * @return Successful Operation
   */
  getWeb3Token(): Promise<Web3Login> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetWeb3Token(_response)
    })
  }

  protected processGetWeb3Token(response: Response): Promise<Web3Login> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Web3Login>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * put words here
   * @param body (optional) words go here
   * @return Successful Operation
   */
  postWeb3Token(
    body?: Web3RequestToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostWeb3Token(_response)
    })
  }

  protected processPostWeb3Token(
    response: Response,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <AccessRefreshTokens>(
                JSON.parse(_responseText, this.jsonParseReviver)
              )
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "The provided signature, confirmation or reset token is invalid",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updatePassword(authorization: string, body: NewPassword): Promise<void> {
    let url_ = this.baseUrl + "/user/password/change"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "PATCH",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdatePassword(_response)
    })
  }

  protected processUpdatePassword(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Password and confirm password do not match",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "New password is same as old password or incorrect old password",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else if (status === 412) {
      return response.text().then((_responseText) => {
        let result412: any = null
        result412 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "New password is weak",
          status,
          _responseText,
          _headers,
          result412,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Updates user info
   * @param email Email Address of the
   * @return Successful Operation
   */
  getResetPassword(email: string): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset/{email}"
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.")
    url_ = url_.replace("{email}", encodeURIComponent("" + email))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetResetPassword(_response)
    })
  }

  protected processGetResetPassword(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "No user found With this email",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Reset Email sent Recently",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Complete the Password reset process
   * @param body Updated user object
   * @return Successful Operation
   */
  postPasswordReset(body: ResetPassword): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostPasswordReset(_response)
    })
  }

  protected processPostPasswordReset(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Password and confirm password do not match",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Reset Email sent Recently",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else if (status === 412) {
      return response.text().then((_responseText) => {
        let result412: any = null
        result412 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Confirmation or reset token expired",
          status,
          _responseText,
          _headers,
          result412,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Complete a Password the Password reset process
   * @param body words go here
   * @return Successful Operation
   */
  postPasswordResetVerify(body: VerifyPasswordReset): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostPasswordResetVerify(_response)
    })
  }

  protected processPostPasswordResetVerify(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Confirmation or reset token is invalid",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else if (status === 412) {
      return response.text().then((_responseText) => {
        let result412: any = null
        result412 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Confirmation or reset token expired",
          status,
          _responseText,
          _headers,
          result412,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Creates a new project
   * @param body information about a project
   * @return Successful Operation
   */
  addproject(authorization: string, body: ProjectRequest): Promise<Project> {
    let url_ = this.baseUrl + "/project/create"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddproject(_response)
    })
  }

  protected processAddproject(response: Response): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Project>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 429) {
      return response.text().then((_responseText) => {
        let result429: any = null
        result429 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Maximum project creation limit for a user reached",
          status,
          _responseText,
          _headers,
          result429,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Project with same name already exists",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * this operation soft deletes a project and no longer be visible to the user
   * @param id identification number of the project
   * @return Successful Operation
   */
  deleteproject(authorization: string, id: number): Promise<void> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteproject(_response)
    })
  }

  protected processDeleteproject(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Requested project not found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid action. Similar kind of action or dependent action already in pending",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * put words here
   * @param id identification number of the project
   * @param body information about a project sent in a request
   * @return Successful Operation
   */
  updateproject(
    authorization: string,
    id: number,
    body: ProjectRequest,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "PATCH",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateproject(_response)
    })
  }

  protected processUpdateproject(response: Response): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Project>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "project does not exist",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "project with the same name already exists",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid action. Similar kind of action or dependent action already in pending",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieves information about a specific project
   * @param id identification number of the project
   * @return Successful Operation
   */
  getProject(authorization: string, id: number): Promise<Project> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetProject(_response)
    })
  }

  protected processGetProject(response: Response): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Project>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "requested project not found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * this operation retrieves all projects for a given user
   * @return an array of project objects
   */
  getallproject(authorization: string): Promise<Project[]> {
    let url_ = this.baseUrl + "/projects"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetallproject(_response)
    })
  }

  protected processGetallproject(response: Response): Promise<Project[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Project[]>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * Deploy a blockchain environment
   * @param body information about a project
   * @return an array of project objects
   */
  addDeployment(
    authorization: string,
    body: NewDeploymentRequest,
  ): Promise<Deployment> {
    let url_ = this.baseUrl + "/deployment/create"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddDeployment(_response)
    })
  }

  protected processAddDeployment(response: Response): Promise<Deployment> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Deployment>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Requested project not found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 412) {
      return response.text().then((_responseText) => {
        let result412: any = null
        result412 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "user's email is not verified or No payment method added before deploying nodes",
          status,
          _responseText,
          _headers,
          result412,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid action. Similar kind of action or dependent action already in pending or Non existing params for deployment",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * this operation deprovisions a deployed blockchain environment in AWS
   * @param id identification number of the deployment
   * @return Successful Operation
   */
  deletedeployment(authorization: string, id: number): Promise<void> {
    let url_ = this.baseUrl + "/deployment/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeletedeployment(_response)
    })
  }

  protected processDeletedeployment(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Requested deployment not found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid action. Similar kind of action or dependent action already in pending",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * this operation retuns the status of an active deployment
   * @param id identification number of the deployment
   * @return Successful Operation.  Valid values areCreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12, Unhealthy = 13
   */
  getdeploymentstatus(authorization: string, id: number): Promise<number> {
    let url_ = this.baseUrl + "/deployment/{id}/status"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetdeploymentstatus(_response)
    })
  }

  protected processGetdeploymentstatus(response: Response): Promise<number> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <number>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Requested deployment not exists for the user",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * this operation returns an array of actve deployments
   * @param id identification number of the deployment
   * @return an array of deployment objects
   */
  getdeployments(authorization: string, id: number): Promise<Deployment[]> {
    let url_ = this.baseUrl + "/project/{id}/deployments"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetdeployments(_response)
    })
  }

  protected processGetdeployments(response: Response): Promise<Deployment[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Deployment[]>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  addCard(authorization: string, body: AddCardRequest): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/add"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddCard(_response)
    })
  }

  protected processAddCard(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing Authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        result403 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid card",
          status,
          _responseText,
          _headers,
          result403,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  updateDefaultCard(authorization: string, body: CardID): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "PATCH",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateDefaultCard(_response)
    })
  }

  protected processUpdateDefaultCard(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid card id",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Card not found with requested id",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  getDefaultCard(authorization: string): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetDefaultCard(_response)
    })
  }

  protected processGetDefaultCard(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Card not found with requested id",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  deleteCard(authorization: string, id: number): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteCard(_response)
    })
  }

  protected processDeleteCard(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Card not found with requested id",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Invalid card id",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getCard(authorization: string, id: number): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetCard(_response)
    })
  }

  protected processGetCard(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Card not found with requested id",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getAllCards(authorization: string): Promise<void> {
    let url_ = this.baseUrl + "/billing/cards"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllCards(_response)
    })
  }

  protected processGetAllCards(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/invoices/object
   */
  getAllInvoices(authorization: string): Promise<void> {
    let url_ = this.baseUrl + "/billing/invoices"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllInvoices(_response)
    })
  }

  protected processGetAllInvoices(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getSubscription(authorization: string, id: number): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscriptions/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSubscription(_response)
    })
  }

  protected processGetSubscription(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "subscription not found with requested id",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getAllSubscriptions(authorization: string): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscriptions"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllSubscriptions(_response)
    })
  }

  protected processGetAllSubscriptions(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * upload a bunch of files to the pin service
   * @param file (optional)
   * @param path (optional)
   * @param replication (optional)
   * @param deal_duration (optional)
   * @return Successful Operation
   */
  uploadPins(
    authorization: string,
    file?: any | undefined,
    path?: string | undefined,
    replication?: number | undefined,
    deal_duration?: boolean | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.")
    else content_.append("file", file.toString())
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())
    if (replication === null || replication === undefined)
      throw new Error("The parameter 'replication' cannot be null.")
    else content_.append("replication", replication.toString())
    if (deal_duration === null || deal_duration === undefined)
      throw new Error("The parameter 'deal_duration' cannot be null.")
    else content_.append("deal_duration", deal_duration.toString())

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUploadPins(_response)
    })
  }

  protected processUploadPins(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing Authorization token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Drive Service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "file store do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * get pin object info
   * @param pin_id pin object cid
   * @return Successful Operation,
   */
  getPinsByCID(authorization: string, pin_id: string): Promise<Anonymous2> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPinsByCID(_response)
    })
  }

  protected processGetPinsByCID(response: Response): Promise<Anonymous2> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous2>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing authorization token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "no pins with CID was found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * delete the pin object
   * @param pin_id pin object cid
   * @return Successful Operation
   */
  deletePins(authorization: string, pin_id: string): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeletePins(_response)
    })
  }

  protected processDeletePins(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "No pins with CID was found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  updatePin(authorization: string, pin_id: string, body: Body): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdatePin(_response)
    })
  }

  protected processUpdatePin(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "No pins with CID was found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "No pin data was provider for modification",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * add pin objects
   * @param body words go here
   * @return Successful Operation
   */
  addPin(api_key: string, body: Body2): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddPin(_response)
    })
  }

  protected processAddPin(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing Authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "no pins with CID was found",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  getAllPins(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
  ): Promise<Anonymous3[]> {
    let url_ = this.baseUrl + "/fps/pins?"
    if (status === null)
      throw new Error("The parameter 'status' cannot be null.")
    else if (status !== undefined)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    if (limit === null) throw new Error("The parameter 'limit' cannot be null.")
    else if (limit !== undefined)
      url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    if (cid === null) throw new Error("The parameter 'cid' cannot be null.")
    else if (cid !== undefined)
      url_ += "cid=" + encodeURIComponent("" + cid) + "&"
    if (before === null)
      throw new Error("The parameter 'before' cannot be null.")
    else if (before !== undefined)
      url_ += "before=" + encodeURIComponent("" + before) + "&"
    if (after === null) throw new Error("The parameter 'after' cannot be null.")
    else if (after !== undefined)
      url_ += "after=" + encodeURIComponent("" + after) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllPins(_response)
    })
  }

  protected processGetAllPins(response: Response): Promise<Anonymous3[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous3[]>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 429) {
      return response.text().then((_responseText) => {
        let result429: any = null
        result429 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "max limit of returned pin objects is 1000 and min is 1",
          status,
          _responseText,
          _headers,
          result429,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve asks
   * @return Successful Operation returns objects referenced here  https://github.com/textileio/powergate/blob/master/index/ask/types.go
   */
  getAsks(api_key: string): Promise<Anonymous4> {
    let url_ = this.baseUrl + "/powergate/asks"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAsks(_response)
    })
  }

  protected processGetAsks(response: Response): Promise<Anonymous4> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous4>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "invalid or missing bearer token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation returns a deal record object referenced here https://github.com/textileio/powergate/blob/master/deals/types.go
   */
  getDeals(
    api_key: string,
    direction: Direction,
    only?: Only | undefined,
  ): Promise<Anonymous5> {
    let url_ = this.baseUrl + "/powergate/deals?"
    if (direction === undefined || direction === null)
      throw new Error(
        "The parameter 'direction' must be defined and cannot be null.",
      )
    else url_ += "direction=" + encodeURIComponent("" + direction) + "&"
    if (only === null) throw new Error("The parameter 'only' cannot be null.")
    else if (only !== undefined)
      url_ += "only=" + encodeURIComponent("" + only) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetDeals(_response)
    })
  }

  protected processGetDeals(response: Response): Promise<Anonymous5> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous5>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "invalid or missing bearer tokeng",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "no direction query parameter was provided in a request",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve faults
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/faults/types.go
   */
  getFaults(authorization: string): Promise<Anonymous6> {
    let url_ = this.baseUrl + "/powergate/faults"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetFaults(_response)
    })
  }

  protected processGetFaults(response: Response): Promise<Anonymous6> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous6>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "invalid or missing bearer token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "no direction query parameter was provided in a request",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve miners
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getMiners(authorization: string): Promise<Anonymous7> {
    let url_ = this.baseUrl + "/powergate/miners"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "applicaiton/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetMiners(_response)
    })
  }

  protected processGetMiners(response: Response): Promise<Anonymous7> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous7>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "invalid or missing bearer token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve peers
   * @return Successful Operation returns objects referenced here hhttps://github.com/textileio/powergate/blob/master/net/interface.go
   */
  getPeers(authorization: string): Promise<Anonymous8> {
    let url_ = this.baseUrl + "/powergate/peers"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "applicaiton/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPeers(_response)
    })
  }

  protected processGetPeers(response: Response): Promise<Anonymous8> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous8>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "invalid or missing bearer token",
          status,
          _responseText,
          _headers,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getTopMiners(api_key: string, limit: number): Promise<Anonymous9> {
    let url_ = this.baseUrl + "/powergate/reputation/topminers?"
    if (limit === undefined || limit === null)
      throw new Error(
        "The parameter 'limit' must be defined and cannot be null.",
      )
    else url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetTopMiners(_response)
    })
  }

  protected processGetTopMiners(response: Response): Promise<Anonymous9> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous9>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "invalid or missing bearer token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 429) {
      return response.text().then((_responseText) => {
        let result429: any = null
        result429 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "provided limit is invalid",
          status,
          _responseText,
          _headers,
          result429,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * returns file store info
   * @return Successful Operation
   */
  getFileStoreInfo(authorization: string): Promise<Anonymous10> {
    let url_ = this.baseUrl + "/drive/info"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetFileStoreInfo(_response)
    })
  }

  protected processGetFileStoreInfo(response: Response): Promise<Anonymous10> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <Anonymous10>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing Authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File of directory name in conflict with existing structure",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "Drive Service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve file content
   * @param body file path
   * @return Successful Operation
   */
  getFileContent(authorization: string, body: FileRequest): Promise<void> {
    let url_ = this.baseUrl + "/drive/download"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetFileContent(_response)
    })
  }

  protected processGetFileContent(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing Authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "drive service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File with such CID does not exists",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * uploads a file
   * @param file (optional)
   * @param path (optional)
   * @param type (optional)
   * @param update (optional)
   * @return Successful Operation
   */
  addFile(
    authorization: string,
    file?: string | undefined,
    path?: string | undefined,
    type?: string | undefined,
    update?: boolean | undefined,
  ): Promise<AddFileResponse> {
    let url_ = this.baseUrl + "/drive/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.")
    else content_.append("file", file.toString())
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())
    if (type === null || type === undefined)
      throw new Error("The parameter 'type' cannot be null.")
    else content_.append("type", type.toString())
    if (update === null || update === undefined)
      throw new Error("The parameter 'update' cannot be null.")
    else content_.append("update", update.toString())

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddFile(_response)
    })
  }

  protected processAddFile(response: Response): Promise<AddFileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : <AddFileResponse>JSON.parse(_responseText, this.jsonParseReviver)
        return result200
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing Authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "drive service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "file of directory name in conflict with existing structure",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveObject(authorization: string, body: FileRequest): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/mv"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMoveObject(_response)
    })
  }

  protected processMoveObject(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid or missing Authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "drive service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store or File Name do not exists for the provided user",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "file of directory name in conflict with existing structure",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getFileInfo(authorization: string, body: FileRequest): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/file"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetFileInfo(_response)
    })
  }

  protected processGetFileInfo(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "drive service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store or File itself do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result400,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * removes a file or empty directory
   * @param body file path
   * @return Successful Operation
   */
  removeObject(authorization: string, body: FileRequest): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/rm"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "GET",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRemoveObject(_response)
    })
  }

  protected processRemoveObject(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "drive service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store or File do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getChildList(authorization: string, body: FileRequest): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/ls"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetChildList(_response)
    })
  }

  protected processGetChildList(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "drive service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }

  /**
   * creates new directory
   * @param body file path
   * @return Successful Operation
   */
  addDirectory(authorization: string, body: FileRequest): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/mkdir"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddDirectory(_response)
    })
  }

  protected processAddDirectory(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "Invalid authentication token",
          status,
          _responseText,
          _headers,
        )
      })
    } else if (status === 503) {
      return response.text().then((_responseText) => {
        let result503: any = null
        result503 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "drive service is not inilialized",
          status,
          _responseText,
          _headers,
          result503,
        )
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "File Store do not exists for the provided user identifier",
          status,
          _responseText,
          _headers,
          result404,
        )
      })
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null
        result409 =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "file of directory name in conflict with existing structure",
          status,
          _responseText,
          _headers,
          result409,
        )
      })
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null
        resultdefault =
          _responseText === ""
            ? null
            : <Anonymous[]>JSON.parse(_responseText, this.jsonParseReviver)
        return throwException(
          "server error",
          status,
          _responseText,
          _headers,
          resultdefault,
        )
      })
    }
  }
}

export interface FileRequest {
  /** path to the file object */
  path: string
  /** used to change the destination of a request */
  source?: string
}

export interface Login {
  /** Email Address of the user */
  email: string
  /** Password of the user */
  password: string
}

export interface Token {
  /** Authentication token used for api access */
  token?: string
  /** The Expiration date of the token */
  expires?: string
}

export interface AccessRefreshTokens {
  /** Authentication Token used for API access */
  access_token?: any
  /** Refresh Token used for API access */
  refresh_token?: any
}

export interface UserSignUp {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Password of the User */
  password: string
}

export interface UserPatch {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Email Address of the User */
  email: string
  /** UserName of the User */
  username?: string
  /** Phone Number of the User */
  phone?: string
  /** City of the User */
  city?: string
  /** Country of the User */
  country?: string
}

export interface User {
  /** Identification Number of the User */
  id?: number
  /** Timestamp of the User creation event */
  created_at?: string
  /** Timestamp of the last User last update */
  updated_at?: string
  /** Timestamp of the Users Delete event */
  deleted_at?: string
  /** The Universal Unique Identifier of the User */
  uuid?: string
  /** First Name of tne User */
  first_name?: string
  /** Last Name of the User */
  last_name?: string
  /** UserName of the User */
  username?: string
  /** Public Address of the User */
  public_address?: string
  /** Email Address of the User */
  email?: string
  /** Phone number of the User */
  phone?: string
  /** Is the User Active */
  active?: boolean
  /** Is the User Verified */
  verified?: boolean
  /** Is the User Payments Activated */
  payment_active?: boolean
  /** Timestamp of the Users last login */
  last_login?: string
  /** Timpstamp of the User's last password change */
  last_password_change?: string
  /** Timestamp of the User's last email change */
  last_email_change?: string
  /** IP address of the User's last login */
  login_ip?: string
  /** Timestamp of the last User login */
  login_at?: string
  /** Browser used by the User last */
  browser?: string
  /** City the User has registered */
  city?: string
  /** Country the User has registered */
  country?: string
}

export interface VerifyEmailToken {
  /** Identification Number of the User */
  id: number
  /** Authenticaton Token */
  token: string
}

export interface Web3Login {
  /** Token from the */
  token?: string
  expires?: string
}

export interface Web3RequestToken {
  /** Public Address of the user */
  public_address?: string
  /** Token gotten from calling the web3 login API */
  token: string
  /** Signature of the Token generated using user's Private Key */
  signature: string
}

export interface NewPassword {
  /** Current password of the user */
  old_password: string
  /** The password that will be set as current password */
  new_password: string
  /** Same as new_password */
  confirm_password?: string
}

export interface ResetPassword {
  /** the id that was sent in the email */
  id: number
  /** token sent in email */
  token: string
  /** New Password to be set for the User */
  password: string
  /** Same as password */
  password_confirm: string
}

export interface VerifyPasswordReset {
  /** id that was sent to email */
  id: number
  /** token sent in email */
  token: string
}

export interface ProjectRequest {
  /** Name of the Project and must be unique for a User */
  name: string
  /** Description of the project */
  description?: string
}

export interface Project {
  /** unique id of the project */
  id?: number
  /** creation time fo the Project */
  created_at?: string
  /** last time when project information was changed */
  updated_at?: string
  /** deleted_at is set when user deletes the project */
  deleted_at?: string
  /** name of the project */
  name?: string
  /** description of the project */
  description?: string
  /** status of the project. */
  status?: number
  /** user id for this project */
  user_id?: number
  /** redundant field */
  billing?: boolean
  /** api Key for this project */
  api_key?: string
  /** API Secret for this project */
  api_secret?: string
}

export interface NewDeploymentRequest {
  /** Project id for this deployment */
  project_id: number
  /** Currently eth (Ethereum) and etc (Ethereum classic) are supported */
  chain: string
  /** Type of blockchain network */
  network: NewDeploymentRequestNetwork
}

export interface Deployment {
  /** Unique id of the deployment */
  id?: number
  /** Creation time fo the deployment */
  created_at?: string
  /** Last time when deployment information was changed */
  updated_at?: string
  /** Deleted_at is set when user deletes the deployment */
  deleted_at?: string
  /** Name generated for this deployment */
  name?: string
  /** Type of the deployment */
  type?: string
  /** The specific software project eth (Ethereum) and etc (Ethereum classic) are supported */
  chain?: DeploymentChain
  /** For eth chain, mainnet, goerli, rinkeby, ropsten network are supported. And for etc chain, mainnet, kotti, mordor are supported. */
  network?: DeploymentNetwork
  /** Status of the deployment. CreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12 */
  status?: number
  /** Project id for this deployment */
  project_id?: number
  /** User id for this deployment */
  user_id?: number
}

export interface AddCardRequest {
  /** card token returned from stripe */
  token: string
}

export interface CardID {
  /** id of the card that you want to perform an action on */
  id: number
}

export interface Body {
  /** words go here */
  pin?: Pin
  /** words go here */
  deal?: Deal
}

export interface Body2 {
  /** arrary of objects to be pinned */
  pin?: Pin2[]
  /** info about the deal */
  deal?: Deal2
}

export type Status = "queued" | "failed" | "pinning" | "pinned"

export type Direction = "retrieval" | "storage"

export type Only = "final" | "pending"

export interface Anonymous {
  /** The type or category of error */
  error_type?: string
  /** The error message */
  message?: string
}

export interface Anonymous2 {
  /** pin object identifier */
  id?: string
  /** date and time of pin object creation */
  create?: Date
  /** current status of pinned object */
  status?: Status2
  /** list of providers in which returned cid can be found */
  delegates?: string[]
  /** pin itself */
  pin?: Pin3
  /** words go here */
  deal?: Deal3
}

/** array of pin objects */
export interface Anonymous3 {
  /** pin object identifier */
  id?: string
  /** date and time of pin object creation */
  create?: Date
  /** current status of pinned object */
  status?: Status3
  /** list of providers in which returned cid can be found */
  delegates?: string[]
  /** pin itself */
  pin?: Pin4
}

export interface Anonymous4 {
  /** date last updated_at */
  lastupdated?: string
  /** storeage median price */
  storagemedianprice?: number
  /** information about the storage ask */
  storage?: any
}

export interface Anonymous5 {
  /** the deal record either type storage or retrieval */
  dealrecord?: string
}

export interface Anonymous6 {
  /** words go here */
  tipsetkey?: string
  /** words go here */
  miners?: any
}

export interface Anonymous7 {
  /** workds go here */
  meta?: any
  /** words go here */
  onchain?: any
}

export interface Anonymous8 {
  /** provides address info and location info about a peer */
  peerinfo?: any
}

/** miner info */
export interface Anonymous9 {
  /** miner's score */
  minerscore?: any
}

export interface Anonymous10 {
  /** FFs id */
  ffs_id?: string
  /** size of the File Store in bytes */
  size?: number
  /** size of the encrypted File Store in bytes */
  encrypted_size?: number
  /** wallet addresses */
  wallets?: string[]
  /** api key used for access */
  api_key?: string
}

export interface AddFileResponse {
  /** cid in IPFS */
  cid?: string
  /** file name */
  name?: string
  /** size in bytes */
  size?: number
  /** content type */
  content_type?: string
}

export type NewDeploymentRequestNetwork =
  | "mainnet"
  | "goerli"
  | "rinkeby"
  | "kotti"
  | "mordor"

export type DeploymentChain = "eth" | "etc"

export type DeploymentNetwork =
  | "mainnet"
  | "goerlio"
  | "rinkeby"
  | "ropsten"
  | "kotti"
  | "mordor"

export interface Pin {
  /** file cid */
  cid?: string
}

export interface Deal {
  /** words go here */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export interface Pin2 {
  /** file identification number */
  cid?: string
  /** list of hint-providers for the pin */
  providers?: string[]
}

export interface Deal2 {
  /** length of the deal */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export type Status2 = "queued" | "pinning" | "pinned" | "failed"

export interface Pin3 {
  /** file identification number */
  cid?: string
  /** list of providers hints provided by user on the time of pinning */
  origins?: string[]
}

export interface Deal3 {
  /** words go here */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export type Status3 = "queued" | "pinning" | "pinned" | "failed"

export interface Pin4 {
  /** file identification number */
  cid?: string
  /** list of providers hints provided by user on the time of pinning */
  origins?: string[]
}

export class ApiException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isApiException = true

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result
  else throw new ApiException(message, status, response, headers, null)
}
