/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios"

export interface IImployApiClient {
  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  userLogin(body: Login): Promise<AuthenticationResponse[]>
  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  userSignup(body: UserSignUp): Promise<User>
  /**
   * Get User Data based on BearToken
   * @return successful operation
   */
  userGet(authorization: string): Promise<User>
  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  userPatch(authorization: string, body: UserPatch): Promise<User>
  /**
   * Get email verification link
   * @return successful operation
   */
  userEmailVerifyGet(authorization: string): Promise<void>
  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  userEmailVerifyPost(
    authorization: string,
    body: VerifyEmailToken,
  ): Promise<void>
  /**
   * put words here
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  userRefresh(token: string): Promise<AuthenticationResponse[]>
  /**
   * put words here
   * @return Successful Operation
   */
  userWeb3LoginGet(): Promise<Web3Login>
  /**
   * put words here
   * @param body (optional) words go here
   * @return Successful Operation
   */
  userWeb3LoginPost(
    body?: Web3RequestToken | undefined,
  ): Promise<AuthenticationResponse>
  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  userPasswordChange(authorization: string, body: NewPassword): Promise<void>
  /**
   * Updates user info
   * @param email Email Address of the
   * @return Successful Operation
   */
  userPasswordResetGet(email: string): Promise<void>
  /**
   * Complete the Password reset process
   * @param body Updated user object
   * @return Successful Operation
   */
  userPasswordResetPost(body: ResetPassword): Promise<void>
  /**
   * Complete a Password the Password reset process
   * @param body words go here
   * @return Successful Operation
   */
  userPasswordResetVerify(body: VerifyPasswordReset): Promise<void>
  /**
   * Creates a new project
   * @param body information about a project
   * @return Successful Operation
   */
  projectCreate(authorization: string, body: ProjectRequest): Promise<Project>
  /**
   * this operation soft deletes a project and no longer be visible to the user
   * @param id identification number of the project
   * @return Successful Operation
   */
  projectDelete(authorization: string, id: number): Promise<void>
  /**
   * put words here
   * @param id identification number of the project
   * @param body information about a project sent in a request
   * @return Successful Operation
   */
  projectPatch(
    authorization: string,
    id: number,
    body: ProjectRequest,
  ): Promise<Project>
  /**
   * retrieves information about a specific project
   * @param id identification number of the project
   * @return Successful Operation
   */
  projectGet(authorization: string, id: number): Promise<Project>
  /**
   * this operation retrieves all projects for a given user
   * @return an array of project objects
   */
  projects(authorization: string): Promise<Project[]>
  /**
   * Deploy a blockchain environment
   * @param body information about a project
   * @return an array of project objects
   */
  deploymentCreate(
    authorization: string,
    body: NewDeploymentRequest,
  ): Promise<Deployment>
  /**
   * this operation deprovisions a deployed blockchain environment in AWS
   * @param id identification number of the deployment
   * @return Successful Operation
   */
  deployment(authorization: string, id: number): Promise<void>
  /**
   * this operation retuns the status of an active deployment
   * @param id identification number of the deployment
   * @return Successful Operation.  Valid values areCreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12, Unhealthy = 13
   */
  deploymentStatus(authorization: string, id: number): Promise<number>
  /**
   * this operation returns an array of actve deployments
   * @param id identification number of the deployment
   * @return an array of deployment objects
   */
  projectDeployments(authorization: string, id: number): Promise<Deployment[]>
  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCardAdd(authorization: string, body: AddCardRequest): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  billingCardDefaultPatch(authorization: string, body: CardID): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  billingCardDefaultGet(authorization: string): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCardDelete(authorization: string, id: number): Promise<void>
  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCardGet(authorization: string, id: number): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCards(authorization: string): Promise<void>
  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/invoices/object
   */
  billingInvoices(authorization: string): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  billingSubscriptionsGet(authorization: string, id: number): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  billingSubscriptionsGet(authorization: string): Promise<void>
  /**
   * upload a bunch of files to the pin service
   * @param file (optional)
   * @param path (optional)
   * @param replication (optional)
   * @param deal_duration (optional)
   * @return Successful Operation
   */
  fpsUpload(
    authorization: string,
    file?: any | undefined,
    path?: string | undefined,
    replication?: number | undefined,
    deal_duration?: boolean | undefined,
  ): Promise<void>
  /**
   * get pin object info
   * @param pin_id pin object cid
   * @return Successful Operation,
   */
  fpsPinsGet(authorization: string, pin_id: string): Promise<Anonymous3>
  /**
   * delete the pin object
   * @param pin_id pin object cid
   * @return Successful Operation
   */
  fpsPinsDelete(authorization: string, pin_id: string): Promise<void>
  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  fpsPinsPost(authorization: string, pin_id: string, body: Body): Promise<void>
  /**
   * add pin objects
   * @param body words go here
   * @return Successful Operation
   */
  fpsPinsPost(api_key: string, body: Body2): Promise<void>
  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  fpsPinsGet(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
  ): Promise<Anonymous4[]>
  /**
   * retrieve asks
   * @return Successful Operation returns objects referenced here  https://github.com/textileio/powergate/blob/master/index/ask/types.go
   */
  powergateAsks(api_key: string): Promise<Anonymous5>
  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation returns a deal record object referenced here https://github.com/textileio/powergate/blob/master/deals/types.go
   */
  powergateDeals(
    api_key: string,
    direction: Direction,
    only?: Only | undefined,
  ): Promise<Anonymous6>
  /**
   * retrieve faults
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/faults/types.go
   */
  powergateFaults(authorization: string): Promise<Anonymous7>
  /**
   * retrieve miners
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  powergateMiners(authorization: string): Promise<Anonymous8>
  /**
   * retrieve peers
   * @return Successful Operation returns objects referenced here hhttps://github.com/textileio/powergate/blob/master/net/interface.go
   */
  powergatePeers(authorization: string): Promise<Anonymous9>
  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  powergateReputationTopminers(
    api_key: string,
    limit: number,
  ): Promise<Anonymous10>
  /**
   * returns file store info
   * @return Successful Operation
   */
  driveInfo(authorization: string): Promise<Anonymous11>
  /**
   * retrieve file content
   * @param body file path
   * @return Successful Operation
   */
  driveDownload(authorization: string, body: FileRequest): Promise<void>
  /**
   * uploads a file
   * @param file (optional)
   * @param path (optional)
   * @param type (optional)
   * @param update (optional)
   * @return Successful Operation
   */
  driveUpload(
    authorization: string,
    file?: string | undefined,
    path?: string | undefined,
    type?: string | undefined,
    update?: boolean | undefined,
  ): Promise<Anonymous12>
  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  driveFilesMv(authorization: string, body: FileRequest): Promise<void>
  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  driveFilesFile(authorization: string, body: FileRequest): Promise<void>
  /**
   * removes a file or empty directory
   * @param body file path
   * @return Successful Operation
   */
  driveFilesRm(authorization: string, body: FileRequest): Promise<void>
  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  driveFilesLs(authorization: string, body: FileRequest): Promise<void>
  /**
   * creates new directory
   * @param body file path
   * @return Successful Operation
   */
  driveFilesMkdir(authorization: string, body: FileRequest): Promise<void>
}

export class ImployApiClient implements IImployApiClient {
  private instance: AxiosInstance
  private baseUrl: string
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl ? baseUrl : "https://stage.api.chainsafe.site"
  }

  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  userLogin(
    body: Login,
    cancelToken?: CancelToken | undefined,
  ): Promise<AuthenticationResponse[]> {
    let url_ = this.baseUrl + "/user/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserLogin(_response)
      })
  }

  protected processUserLogin(
    response: AxiosResponse,
  ): Promise<AuthenticationResponse[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid username/password supplied",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  userSignup(
    body: UserSignUp,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user/signup"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserSignup(_response)
      })
  }

  protected processUserSignup(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Bad Request Binding",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Bad Request Password Not Matching",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Bad Request Email Already Exists",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Get User Data based on BearToken
   * @return successful operation
   */
  userGet(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserGet(_response)
      })
  }

  protected processUserGet(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  userPatch(
    authorization: string,
    body: UserPatch,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserPatch(_response)
      })
  }

  protected processUserPatch(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email Verification sent recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "User with this email, phone number or username already exists",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Get email verification link
   * @return successful operation
   */
  userEmailVerifyGet(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserEmailVerifyGet(_response)
      })
  }

  protected processUserEmailVerifyGet(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Email already verified",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email sent recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  userEmailVerifyPost(
    authorization: string,
    body: VerifyEmailToken,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserEmailVerifyPost(_response)
      })
  }

  protected processUserEmailVerifyPost(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "Confirmation or reset token expired",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email already verified",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  userRefresh(
    token: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<AuthenticationResponse[]> {
    let url_ = this.baseUrl + "/user/refresh/{token}"
    if (token === undefined || token === null)
      throw new Error("The parameter 'token' must be defined.")
    url_ = url_.replace("{token}", encodeURIComponent("" + token))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserRefresh(_response)
      })
  }

  protected processUserRefresh(
    response: AxiosResponse,
  ): Promise<AuthenticationResponse[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @return Successful Operation
   */
  userWeb3LoginGet(cancelToken?: CancelToken | undefined): Promise<Web3Login> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserWeb3LoginGet(_response)
      })
  }

  protected processUserWeb3LoginGet(
    response: AxiosResponse,
  ): Promise<Web3Login> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @param body (optional) words go here
   * @return Successful Operation
   */
  userWeb3LoginPost(
    body?: Web3RequestToken | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<AuthenticationResponse> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserWeb3LoginPost(_response)
      })
  }

  protected processUserWeb3LoginPost(
    response: AxiosResponse,
  ): Promise<AuthenticationResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "The provided signature, confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  userPasswordChange(
    authorization: string,
    body: NewPassword,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/change"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserPasswordChange(_response)
      })
  }

  protected processUserPasswordChange(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Password and confirm password do not match",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "New password is same as old password or incorrect old password",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "New password is weak",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Updates user info
   * @param email Email Address of the
   * @return Successful Operation
   */
  userPasswordResetGet(
    email: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset/{email}"
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.")
    url_ = url_.replace("{email}", encodeURIComponent("" + email))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserPasswordResetGet(_response)
      })
  }

  protected processUserPasswordResetGet(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No user found With this email",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Reset Email sent Recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Complete the Password reset process
   * @param body Updated user object
   * @return Successful Operation
   */
  userPasswordResetPost(
    body: ResetPassword,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserPasswordResetPost(_response)
      })
  }

  protected processUserPasswordResetPost(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Password and confirm password do not match",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Reset Email sent Recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "Confirmation or reset token expired",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Complete a Password the Password reset process
   * @param body words go here
   * @return Successful Operation
   */
  userPasswordResetVerify(
    body: VerifyPasswordReset,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUserPasswordResetVerify(_response)
      })
  }

  protected processUserPasswordResetVerify(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "Confirmation or reset token expired",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Creates a new project
   * @param body information about a project
   * @return Successful Operation
   */
  projectCreate(
    authorization: string,
    body: ProjectRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/create"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processProjectCreate(_response)
      })
  }

  protected processProjectCreate(response: AxiosResponse): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "Maximum project creation limit for a user reached",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Project with same name already exists",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation soft deletes a project and no longer be visible to the user
   * @param id identification number of the project
   * @return Successful Operation
   */
  projectDelete(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processProjectDelete(_response)
      })
  }

  protected processProjectDelete(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested project not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @param id identification number of the project
   * @param body information about a project sent in a request
   * @return Successful Operation
   */
  projectPatch(
    authorization: string,
    id: number,
    body: ProjectRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processProjectPatch(_response)
      })
  }

  protected processProjectPatch(response: AxiosResponse): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "project does not exist",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "project with the same name already exists",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieves information about a specific project
   * @param id identification number of the project
   * @return Successful Operation
   */
  projectGet(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processProjectGet(_response)
      })
  }

  protected processProjectGet(response: AxiosResponse): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "requested project not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation retrieves all projects for a given user
   * @return an array of project objects
   */
  projects(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project[]> {
    let url_ = this.baseUrl + "/projects"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processProjects(_response)
      })
  }

  protected processProjects(response: AxiosResponse): Promise<Project[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Deploy a blockchain environment
   * @param body information about a project
   * @return an array of project objects
   */
  deploymentCreate(
    authorization: string,
    body: NewDeploymentRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<Deployment> {
    let url_ = this.baseUrl + "/deployment/create"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeploymentCreate(_response)
      })
  }

  protected processDeploymentCreate(
    response: AxiosResponse,
  ): Promise<Deployment> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested project not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "user's email is not verified or No payment method added before deploying nodes",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending or Non existing params for deployment",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation deprovisions a deployed blockchain environment in AWS
   * @param id identification number of the deployment
   * @return Successful Operation
   */
  deployment(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/deployment/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeployment(_response)
      })
  }

  protected processDeployment(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested deployment not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation retuns the status of an active deployment
   * @param id identification number of the deployment
   * @return Successful Operation.  Valid values areCreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12, Unhealthy = 13
   */
  deploymentStatus(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<number> {
    let url_ = this.baseUrl + "/deployment/{id}/status"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "text/plain",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeploymentStatus(_response)
      })
  }

  protected processDeploymentStatus(response: AxiosResponse): Promise<number> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested deployment not exists for the user",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation returns an array of actve deployments
   * @param id identification number of the deployment
   * @return an array of deployment objects
   */
  projectDeployments(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Deployment[]> {
    let url_ = this.baseUrl + "/project/{id}/deployments"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processProjectDeployments(_response)
      })
  }

  protected processProjectDeployments(
    response: AxiosResponse,
  ): Promise<Deployment[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCardAdd(
    authorization: string,
    body: AddCardRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/add"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingCardAdd(_response)
      })
  }

  protected processBillingCardAdd(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid card",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  billingCardDefaultPatch(
    authorization: string,
    body: CardID,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingCardDefaultPatch(_response)
      })
  }

  protected processBillingCardDefaultPatch(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid card id",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  billingCardDefaultGet(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingCardDefaultGet(_response)
      })
  }

  protected processBillingCardDefaultGet(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCardDelete(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingCardDelete(_response)
      })
  }

  protected processBillingCardDelete(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid card id",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCardGet(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingCardGet(_response)
      })
  }

  protected processBillingCardGet(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  billingCards(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/cards"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingCards(_response)
      })
  }

  protected processBillingCards(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/invoices/object
   */
  billingInvoices(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/invoices"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingInvoices(_response)
      })
  }

  protected processBillingInvoices(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  billingSubscriptionsGet(
    authorization: string,
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscriptions{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingSubscriptionsGet(_response)
      })
  }

  protected processBillingSubscriptionsGet(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "subscription not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  billingSubscriptionsGet(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscriptions"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBillingSubscriptionsGet(_response)
      })
  }

  protected processBillingSubscriptionsGet(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * upload a bunch of files to the pin service
   * @param file (optional)
   * @param path (optional)
   * @param replication (optional)
   * @param deal_duration (optional)
   * @return Successful Operation
   */
  fpsUpload(
    authorization: string,
    file?: any | undefined,
    path?: string | undefined,
    replication?: number | undefined,
    deal_duration?: boolean | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.")
    else content_.append("file", file.toString())
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())
    if (replication === null || replication === undefined)
      throw new Error("The parameter 'replication' cannot be null.")
    else content_.append("replication", replication.toString())
    if (deal_duration === null || deal_duration === undefined)
      throw new Error("The parameter 'deal_duration' cannot be null.")
    else content_.append("deal_duration", deal_duration.toString())

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFpsUpload(_response)
      })
  }

  protected processFpsUpload(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authorization token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "Drive Service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "file store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * get pin object info
   * @param pin_id pin object cid
   * @return Successful Operation,
   */
  fpsPinsGet(
    authorization: string,
    pin_id: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous3> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFpsPinsGet(_response)
      })
  }

  protected processFpsPinsGet(response: AxiosResponse): Promise<Anonymous3> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing authorization token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "no pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * delete the pin object
   * @param pin_id pin object cid
   * @return Successful Operation
   */
  fpsPinsDelete(
    authorization: string,
    pin_id: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFpsPinsDelete(_response)
      })
  }

  protected processFpsPinsDelete(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  fpsPinsPost(
    authorization: string,
    pin_id: string,
    body: Body,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFpsPinsPost(_response)
      })
  }

  protected processFpsPinsPost(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "No pin data was provider for modification",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * add pin objects
   * @param body words go here
   * @return Successful Operation
   */
  fpsPinsPost(
    api_key: string,
    body: Body2,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFpsPinsPost(_response)
      })
  }

  protected processFpsPinsPost(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "no pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  fpsPinsGet(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous4[]> {
    let url_ = this.baseUrl + "/fps/pins?"
    if (status === null)
      throw new Error("The parameter 'status' cannot be null.")
    else if (status !== undefined)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    if (limit === null) throw new Error("The parameter 'limit' cannot be null.")
    else if (limit !== undefined)
      url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    if (cid === null) throw new Error("The parameter 'cid' cannot be null.")
    else if (cid !== undefined)
      url_ += "cid=" + encodeURIComponent("" + cid) + "&"
    if (before === null)
      throw new Error("The parameter 'before' cannot be null.")
    else if (before !== undefined)
      url_ += "before=" + encodeURIComponent("" + before) + "&"
    if (after === null) throw new Error("The parameter 'after' cannot be null.")
    else if (after !== undefined)
      url_ += "after=" + encodeURIComponent("" + after) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFpsPinsGet(_response)
      })
  }

  protected processFpsPinsGet(response: AxiosResponse): Promise<Anonymous4[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "max limit of returned pin objects is 1000 and min is 1",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve asks
   * @return Successful Operation returns objects referenced here  https://github.com/textileio/powergate/blob/master/index/ask/types.go
   */
  powergateAsks(
    api_key: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous5> {
    let url_ = this.baseUrl + "/powergate/asks"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPowergateAsks(_response)
      })
  }

  protected processPowergateAsks(response: AxiosResponse): Promise<Anonymous5> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation returns a deal record object referenced here https://github.com/textileio/powergate/blob/master/deals/types.go
   */
  powergateDeals(
    api_key: string,
    direction: Direction,
    only?: Only | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous6> {
    let url_ = this.baseUrl + "/powergate/deals?"
    if (direction === undefined || direction === null)
      throw new Error(
        "The parameter 'direction' must be defined and cannot be null.",
      )
    else url_ += "direction=" + encodeURIComponent("" + direction) + "&"
    if (only === null) throw new Error("The parameter 'only' cannot be null.")
    else if (only !== undefined)
      url_ += "only=" + encodeURIComponent("" + only) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPowergateDeals(_response)
      })
  }

  protected processPowergateDeals(
    response: AxiosResponse,
  ): Promise<Anonymous6> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer tokeng",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "no direction query parameter was provided in a request",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve faults
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/faults/types.go
   */
  powergateFaults(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous7> {
    let url_ = this.baseUrl + "/powergate/faults"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPowergateFaults(_response)
      })
  }

  protected processPowergateFaults(
    response: AxiosResponse,
  ): Promise<Anonymous7> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "no direction query parameter was provided in a request",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve miners
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  powergateMiners(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous8> {
    let url_ = this.baseUrl + "/powergate/miners"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPowergateMiners(_response)
      })
  }

  protected processPowergateMiners(
    response: AxiosResponse,
  ): Promise<Anonymous8> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve peers
   * @return Successful Operation returns objects referenced here hhttps://github.com/textileio/powergate/blob/master/net/interface.go
   */
  powergatePeers(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous9> {
    let url_ = this.baseUrl + "/powergate/peers"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPowergatePeers(_response)
      })
  }

  protected processPowergatePeers(
    response: AxiosResponse,
  ): Promise<Anonymous9> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  powergateReputationTopminers(
    api_key: string,
    limit: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous10> {
    let url_ = this.baseUrl + "/powergate/reputation/topminers?"
    if (limit === undefined || limit === null)
      throw new Error(
        "The parameter 'limit' must be defined and cannot be null.",
      )
    else url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPowergateReputationTopminers(_response)
      })
  }

  protected processPowergateReputationTopminers(
    response: AxiosResponse,
  ): Promise<Anonymous10> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "provided limit is invalid",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * returns file store info
   * @return Successful Operation
   */
  driveInfo(
    authorization: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous11> {
    let url_ = this.baseUrl + "/drive/info"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveInfo(_response)
      })
  }

  protected processDriveInfo(response: AxiosResponse): Promise<Anonymous11> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "File of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "Drive Service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve file content
   * @param body file path
   * @return Successful Operation
   */
  driveDownload(
    authorization: string,
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/download"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveDownload(_response)
      })
  }

  protected processDriveDownload(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File with such CID does not exists",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * uploads a file
   * @param file (optional)
   * @param path (optional)
   * @param type (optional)
   * @param update (optional)
   * @return Successful Operation
   */
  driveUpload(
    authorization: string,
    file?: string | undefined,
    path?: string | undefined,
    type?: string | undefined,
    update?: boolean | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous12> {
    let url_ = this.baseUrl + "/drive/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.")
    else content_.append("file", file.toString())
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())
    if (type === null || type === undefined)
      throw new Error("The parameter 'type' cannot be null.")
    else content_.append("type", type.toString())
    if (update === null || update === undefined)
      throw new Error("The parameter 'update' cannot be null.")
    else content_.append("update", update.toString())

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveUpload(_response)
      })
  }

  protected processDriveUpload(response: AxiosResponse): Promise<Anonymous12> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  driveFilesMv(
    authorization: string,
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/mv"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveFilesMv(_response)
      })
  }

  protected processDriveFilesMv(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File Name do not exists for the provided user",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  driveFilesFile(
    authorization: string,
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/file"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveFilesFile(_response)
      })
  }

  protected processDriveFilesFile(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "File Store or File itself do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * removes a file or empty directory
   * @param body file path
   * @return Successful Operation
   */
  driveFilesRm(
    authorization: string,
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/rm"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "GET",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveFilesRm(_response)
      })
  }

  protected processDriveFilesRm(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  driveFilesLs(
    authorization: string,
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/ls"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveFilesLs(_response)
      })
  }

  protected processDriveFilesLs(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * creates new directory
   * @param body file path
   * @return Successful Operation
   */
  driveFilesMkdir(
    authorization: string,
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/mkdir"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Authorization:
          authorization !== undefined && authorization !== null
            ? "" + authorization
            : "",
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDriveFilesMkdir(_response)
      })
  }

  protected processDriveFilesMkdir(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }
}

export interface FileRequest {
  /** path to the file object */
  path: string
  /** used to change the destination of a request */
  source?: string
}

export interface Login {
  /** Email Address of the user */
  email: string
  /** Password of the user */
  password: string
}

export interface Token {
  /** Authentication token used for api access */
  token?: string
  /** The Expiration date of the token */
  expires?: string
}

export interface UserSignUp {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Password of the User */
  password: string
}

export interface UserPatch {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Email Address of the User */
  email: string
  /** UserName of the User */
  username?: string
  /** Phone Number of the User */
  phone?: string
  /** City of the User */
  city?: string
  /** Country of the User */
  country?: string
}

export interface User {
  /** Identification Number of the User */
  id?: number
  /** Timestamp of the User creation event */
  created_at?: string
  /** Timestamp of the last User last update */
  updated_at?: string
  /** Timestamp of the Users Delete event */
  deleted_at?: string
  /** The Universal Unique Identifier of the User */
  uuid?: string
  /** First Name of tne User */
  first_name?: string
  /** Last Name of the User */
  last_name?: string
  /** UserName of the User */
  username?: string
  /** Public Address of the User */
  public_address?: string
  /** Email Address of the User */
  email?: string
  /** Phone number of the User */
  phone?: string
  /** Is the User Active */
  active?: boolean
  /** Is the User Verified */
  verified?: boolean
  /** Is the User Payments Activated */
  payment_active?: boolean
  /** Timestamp of the Users last login */
  last_login?: string
  /** Timpstamp of the User's last password change */
  last_password_change?: string
  /** Timestamp of the User's last email change */
  last_email_change?: string
  /** IP address of the User's last login */
  login_ip?: string
  /** Timestamp of the last User login */
  login_at?: string
  /** Browser used by the User last */
  browser?: string
  /** City the User has registered */
  city?: string
  /** Country the User has registered */
  country?: string
}

export interface VerifyEmailToken {
  /** Identification Number of the User */
  id: number
  /** Authenticaton Token */
  token: string
}

export interface Web3Login {
  /** Token from the */
  token: string
  expires: string
}

export interface Web3RequestToken {
  /** Public Address of the user */
  public_address?: string
  /** Token gotten from calling the web3 login API */
  token: string
  /** Signature of the Token generated using user's Private Key */
  signature: string
}

export interface NewPassword {
  /** Current password of the user */
  old_password: string
  /** The password that will be set as current password */
  new_password: string
  /** Same as new_password */
  confirm_password?: string
}

export interface ResetPassword {
  /** the id that was sent in the email */
  id: number
  /** token sent in email */
  token: string
  /** New Password to be set for the User */
  password: string
  /** Same as password */
  password_confirm: string
}

export interface VerifyPasswordReset {
  /** id that was sent to email */
  id: number
  /** token sent in email */
  token: string
}

export interface ProjectRequest {
  /** Name of the Project and must be unique for a User */
  name: string
  /** Description of the project */
  description?: string
}

export interface Project {
  /** unique id of the project */
  id?: number
  /** creation time fo the Project */
  created_at?: string
  /** last time when project information was changed */
  updated_at?: string
  /** deleted_at is set when user deletes the project */
  deleted_at?: string
  /** name of the project */
  name?: string
  /** description of the project */
  description?: string
  /** status of the project. */
  status?: number
  /** user id for this project */
  user_id?: number
  /** redundant field */
  billing?: boolean
  /** api Key for this project */
  api_key?: string
  /** API Secret for this project */
  api_secret?: string
}

export interface NewDeploymentRequest {
  /** Project id for this deployment */
  project_id: number
  /** Currently eth (Ethereum) and etc (Ethereum classic) are supported */
  chain: string
  /** Type of blockchain network */
  network: NewDeploymentRequestNetwork
}

export interface Deployment {
  /** Unique id of the deployment */
  id?: number
  /** Creation time fo the deployment */
  created_at?: string
  /** Last time when deployment information was changed */
  updated_at?: string
  /** Deleted_at is set when user deletes the deployment */
  deleted_at?: string
  /** Name generated for this deployment */
  name?: string
  /** Type of the deployment */
  type?: string
  /** The specific software project eth (Ethereum) and etc (Ethereum classic) are supported */
  chain?: DeploymentChain
  /** For eth chain, mainnet, goerli, rinkeby, ropsten network are supported. And for etc chain, mainnet, kotti, mordor are supported. */
  network?: DeploymentNetwork
  /** Status of the deployment. CreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12 */
  status?: number
  /** Project id for this deployment */
  project_id?: number
  /** User id for this deployment */
  user_id?: number
}

export interface AddCardRequest {
  /** card token returned from stripe */
  token: string
}

export interface CardID {
  /** id of the card that you want to perform an action on */
  id: number
}

export interface Body {
  /** words go here */
  pin?: Pin
  /** words go here */
  deal?: Deal
}

export interface Body2 {
  /** arrary of objects to be pinned */
  pin?: Pin2[]
  /** info about the deal */
  deal?: Deal2
}

export type Status = "queued" | "failed" | "pinning" | "pinned"

export type Direction = "retrieval" | "storage"

export type Only = "final" | "pending"

export interface AuthenticationResponse {
  /** Authentication Token used for API access */
  access_token?: any
  /** Refresh Token used for API access */
  refresh_token?: any
}

export interface Anonymous3 {
  /** pin object identifier */
  id?: string
  /** date and time of pin object creation */
  create?: Date
  /** current status of pinned object */
  status?: Status2
  /** list of providers in which returned cid can be found */
  delegates?: string[]
  /** pin itself */
  pin?: Pin3
  /** words go here */
  deal?: Deal3
}

/** array of pin objects */
export interface Anonymous4 {
  /** pin object identifier */
  id?: string
  /** date and time of pin object creation */
  create?: Date
  /** current status of pinned object */
  status?: Status3
  /** list of providers in which returned cid can be found */
  delegates?: string[]
  /** pin itself */
  pin?: Pin4
}

export interface Anonymous5 {
  /** date last updated_at */
  lastupdated?: string
  /** storeage median price */
  storagemedianprice?: number
  /** information about the storage ask */
  storage?: any
}

export interface Anonymous6 {
  /** the deal record either type storage or retrieval */
  dealrecord?: string
}

export interface Anonymous7 {
  /** words go here */
  tipsetkey?: string
  /** words go here */
  miners?: any
}

export interface Anonymous8 {
  /** workds go here */
  meta?: any
  /** words go here */
  onchain?: any
}

export interface Anonymous9 {
  /** provides address info and location info about a peer */
  peerinfo?: any
}

/** miner info */
export interface Anonymous10 {
  /** miner's score */
  minerscore?: any
}

export interface Anonymous11 {
  /** FFs id */
  ffs_id?: string
  /** size of the File Store in bytes */
  size?: number
  /** size of the encrypted File Store in bytes */
  encrypted_size?: number
  /** wallet addresses */
  wallets?: string[]
  /** api key used for access */
  api_key?: string
}

export interface Anonymous12 {
  /** cid in IPFS */
  cid?: string
  /** file name */
  name?: string
  /** size in bytes */
  size?: number
  /** content type */
  content_type?: string
}

export type NewDeploymentRequestNetwork =
  | "mainnet"
  | "goerli"
  | "rinkeby"
  | "kotti"
  | "mordor"

export type DeploymentChain = "eth" | "etc"

export type DeploymentNetwork =
  | "mainnet"
  | "goerlio"
  | "rinkeby"
  | "ropsten"
  | "kotti"
  | "mordor"

export interface Pin {
  /** file cid */
  cid?: string
}

export interface Deal {
  /** words go here */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export interface Pin2 {
  /** file identification number */
  cid?: string
  /** list of hint-providers for the pin */
  providers?: string[]
}

export interface Deal2 {
  /** length of the deal */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export type Status2 = "queued" | "pinning" | "pinned" | "failed"

export interface Pin3 {
  /** file identification number */
  cid?: string
  /** list of providers hints provided by user on the time of pinning */
  origins?: string[]
}

export interface Deal3 {
  /** words go here */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export type Status3 = "queued" | "pinning" | "pinned" | "failed"

export interface Pin4 {
  /** file identification number */
  cid?: string
  /** list of providers hints provided by user on the time of pinning */
  origins?: string[]
}

export class ApiException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isApiException = true

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result
  else throw new ApiException(message, status, response, headers, null)
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true
}
