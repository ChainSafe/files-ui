/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios"

export interface IImployApiClient {
  /**
   * Login user into the system
   * @param email The email for login
   * @param password The password for login in clear text
   * @return successful operation
   */
  loginUser(email: string, password: string): Promise<string>
  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(body: User): Promise<void>
  /**
   * Get user by user name
   * @return successful operation
   */
  getUserByName(): Promise<User>
  /**
   * Updates user info
   * @param body Updated user object
   */
  updateUser(body: User): Promise<void>
  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(): Promise<User>
  /**
   * Sends a new email verification link
   * @param body Updated user object
   */
  getNewEmailVerify(body: User): Promise<void>
  /**
   * Updates user info
   * @param body Updated user object
   */
  updatePassword(body: User): Promise<void>
  /**
   * Get user by user name
   * @param token The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  getRefreshToken(token: string): Promise<User>
  /**
   * Create new stripe subscription
   * @param subscriptionID name that need to be updated
   * @return successful operation
   */
  addSubscription(subscriptionID: string): Promise<User>
  /**
   * View stripe subscription
   * @param subscriptionID name that need to be updated
   * @return successful operation
   */
  viewSubscription(subscriptionID: string): Promise<User>
  /**
   * Updates stripe subscription
   * @param body Updated user object
   */
  updateSubscription(body: User): Promise<void>
  /**
   * Cancel stripe subscription
   */
  cancelSubscription(): Promise<void>
  /**
   * Add new card
   * @return successful operation
   */
  addCard(): Promise<User>
  /**
   * View all cards
   * @return successful operation
   */
  viewAllCards(): Promise<User>
  /**
   * View card
   * @param stripeCardID The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  viewCard(stripeCardID: string): Promise<User>
  /**
   * Delete card
   * @param stripeCardID The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  deleteCard(stripeCardID: string): Promise<User>
  /**
   * View default card
   * @return successful operation
   */
  viewDefaultCard(): Promise<User>
  /**
   * Updates default card
   * @return successful operation
   */
  updateDefaultCard(): Promise<User>
  /**
   * View all invoices
   * @return successful operation
   */
  viewAllInvoices(): Promise<User>
  /**
   * View invoice
   * @param stripeInvoiceID The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  viewInvoice(stripeInvoiceID: string): Promise<User>
  /**
   * Creates a new project
   * @param body project object that needs to be added to the store
   */
  addproject(body: Project): Promise<void>
  /**
   * Get all project for an user
   * @return successful operation
   */
  getAllProjects(): Promise<User>
  /**
   * Find project by ID
   * @param projectID ID of project to return
   * @return successful operation
   */
  getprojectById(projectID: number): Promise<Project>
  /**
   * Updates a project in the store
   * @param projectID ID of project that needs to be updated
   * @param body (optional)
   */
  updateProject(projectID: number, body?: Blob | undefined): Promise<void>
  /**
   * Deletes a project
   * @param projectID project id to delete
   * @param api_key (optional)
   */
  deleteproject(projectID: number, api_key?: string | undefined): Promise<void>
  /**
   * Details of each project including list of all deployments
   * @param projectID ID of project to return
   * @return successful operation
   */
  getProjectDetailsById(projectID: number): Promise<Project>
  /**
   * Creates a new Deployment
   * @param body project object that needs to be added to the store
   */
  createDeployment(body: Project, projectID: string): Promise<void>
  /**
   * Get all Deployments for an user
   * @param projectID ID of project to return
   * @return successful operation
   */
  getAllDeployments(projectID: number): Promise<Project>
  /**
   * Get one Deployment
   * @return successful operation
   */
  getDeploymentById(projectID: string, deploymentID: string): Promise<Project>
  /**
   * Deletes a Deployment
   */
  deleteDeployment(projectID: string, deploymentID: string): Promise<void>
  /**
   * Get Deployment status
   * @return successful operation
   */
  getDeploymentStatus(projectID: string, deploymentID: string): Promise<Project>
}

export class ImployApiClient implements IImployApiClient {
  private instance: AxiosInstance
  private baseUrl: string
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl ? baseUrl : "https://alpha.imploy.site"
  }

  /**
   * Login user into the system
   * @param email The email for login
   * @param password The password for login in clear text
   * @return successful operation
   */
  loginUser(
    email: string,
    password: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<string> {
    let url_ = this.baseUrl + "/user/login?"
    if (email === undefined || email === null)
      throw new Error(
        "The parameter 'email' must be defined and cannot be null.",
      )
    else url_ += "email=" + encodeURIComponent("" + email) + "&"
    if (password === undefined || password === null)
      throw new Error(
        "The parameter 'password' must be defined and cannot be null.",
      )
    else url_ += "password=" + encodeURIComponent("" + password) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLoginUser(_response)
      })
  }

  protected processLoginUser(response: AxiosResponse): Promise<string> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username/password supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<string>(<any>null)
  }

  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(body: User, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/user/signup"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSignup(_response)
      })
  }

  protected processSignup(response: AxiosResponse): Promise<void> {
    // @ts-ignore
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    {
      // @ts-ignore
      const _responseText = response.data
      return Promise.resolve<void>(<any>null)
    }
  }

  /**
   * Get user by user name
   * @return successful operation
   */
  getUserByName(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/user/"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserByName(_response)
      })
  }

  protected processGetUserByName(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Updates user info
   * @param body Updated user object
   */
  updateUser(body: User, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/user/"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "*/*",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateUser(_response)
      })
  }

  protected processUpdateUser(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid user supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetEmailVerify(_response)
      })
  }

  protected processGetEmailVerify(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Sends a new email verification link
   * @param body Updated user object
   */
  getNewEmailVerify(
    body: User,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "*/*",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetNewEmailVerify(_response)
      })
  }

  protected processGetNewEmailVerify(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid user supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Updates user info
   * @param body Updated user object
   */
  updatePassword(
    body: User,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/change"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "*/*",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdatePassword(_response)
      })
  }

  protected processUpdatePassword(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid user supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Get user by user name
   * @param token The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  getRefreshToken(
    token: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user/refresh/{token}"
    if (token === undefined || token === null)
      throw new Error("The parameter 'token' must be defined.")
    url_ = url_.replace("{token}", encodeURIComponent("" + token))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRefreshToken(_response)
      })
  }

  protected processGetRefreshToken(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Create new stripe subscription
   * @param subscriptionID name that need to be updated
   * @return successful operation
   */
  addSubscription(
    subscriptionID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/billing/subscription/{subscriptionID}"
    if (subscriptionID === undefined || subscriptionID === null)
      throw new Error("The parameter 'subscriptionID' must be defined.")
    url_ = url_.replace(
      "{subscriptionID}",
      encodeURIComponent("" + subscriptionID),
    )
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddSubscription(_response)
      })
  }

  protected processAddSubscription(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * View stripe subscription
   * @param subscriptionID name that need to be updated
   * @return successful operation
   */
  viewSubscription(
    subscriptionID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/billing/subscription/{subscriptionID}"
    if (subscriptionID === undefined || subscriptionID === null)
      throw new Error("The parameter 'subscriptionID' must be defined.")
    url_ = url_.replace(
      "{subscriptionID}",
      encodeURIComponent("" + subscriptionID),
    )
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processViewSubscription(_response)
      })
  }

  protected processViewSubscription(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Updates stripe subscription
   * @param body Updated user object
   */
  updateSubscription(
    body: User,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscription/{subscriptionID}"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "*/*",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateSubscription(_response)
      })
  }

  protected processUpdateSubscription(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid user supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Cancel stripe subscription
   */
  cancelSubscription(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscription/{subscriptionID}"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCancelSubscription(_response)
      })
  }

  protected processCancelSubscription(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Add new card
   * @return successful operation
   */
  addCard(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/billing/card/add"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddCard(_response)
      })
  }

  protected processAddCard(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * View all cards
   * @return successful operation
   */
  viewAllCards(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/billing/cards"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processViewAllCards(_response)
      })
  }

  protected processViewAllCards(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * View card
   * @param stripeCardID The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  viewCard(
    stripeCardID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/billing/card/{stripeCardID}"
    if (stripeCardID === undefined || stripeCardID === null)
      throw new Error("The parameter 'stripeCardID' must be defined.")
    url_ = url_.replace("{stripeCardID}", encodeURIComponent("" + stripeCardID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processViewCard(_response)
      })
  }

  protected processViewCard(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Delete card
   * @param stripeCardID The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  deleteCard(
    stripeCardID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/billing/card/{stripeCardID}"
    if (stripeCardID === undefined || stripeCardID === null)
      throw new Error("The parameter 'stripeCardID' must be defined.")
    url_ = url_.replace("{stripeCardID}", encodeURIComponent("" + stripeCardID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteCard(_response)
      })
  }

  protected processDeleteCard(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * View default card
   * @return successful operation
   */
  viewDefaultCard(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processViewDefaultCard(_response)
      })
  }

  protected processViewDefaultCard(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Updates default card
   * @return successful operation
   */
  updateDefaultCard(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "PATCH",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateDefaultCard(_response)
      })
  }

  protected processUpdateDefaultCard(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * View all invoices
   * @return successful operation
   */
  viewAllInvoices(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/billing/invoices"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processViewAllInvoices(_response)
      })
  }

  protected processViewAllInvoices(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * View invoice
   * @param stripeInvoiceID The name that needs to be fetched. Use user1 for testing.
   * @return successful operation
   */
  viewInvoice(
    stripeInvoiceID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/billing/invoice/{stripeInvoiceID}"
    if (stripeInvoiceID === undefined || stripeInvoiceID === null)
      throw new Error("The parameter 'stripeInvoiceID' must be defined.")
    url_ = url_.replace(
      "{stripeInvoiceID}",
      encodeURIComponent("" + stripeInvoiceID),
    )
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processViewInvoice(_response)
      })
  }

  protected processViewInvoice(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Creates a new project
   * @param body project object that needs to be added to the store
   */
  addproject(
    body: Project,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/project/create"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddproject(_response)
      })
  }

  protected processAddproject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 405) {
      const _responseText = response.data
      return throwException("Invalid input", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Get all project for an user
   * @return successful operation
   */
  getAllProjects(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/projects"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllProjects(_response)
      })
  }

  protected processGetAllProjects(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<User>(<any>null)
  }

  /**
   * Find project by ID
   * @param projectID ID of project to return
   * @return successful operation
   */
  getprojectById(
    projectID: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{projectID}"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/xml",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetprojectById(_response)
      })
  }

  protected processGetprojectById(response: AxiosResponse): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid ID supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException(
        "project not found",
        status,
        _responseText,
        _headers,
      )
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<Project>(<any>null)
  }

  /**
   * Updates a project in the store
   * @param projectID ID of project that needs to be updated
   * @param body (optional)
   */
  updateProject(
    projectID: number,
    body?: Blob | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/project/{projectID}"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = body

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateProject(_response)
      })
  }

  protected processUpdateProject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 405) {
      const _responseText = response.data
      return throwException("Invalid input", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Deletes a project
   * @param projectID project id to delete
   * @param api_key (optional)
   */
  deleteproject(
    projectID: number,
    api_key?: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/project/{projectID}"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        api_key: api_key !== undefined && api_key !== null ? "" + api_key : "",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteproject(_response)
      })
  }

  protected processDeleteproject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid ID supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException(
        "project not found",
        status,
        _responseText,
        _headers,
      )
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Details of each project including list of all deployments
   * @param projectID ID of project to return
   * @return successful operation
   */
  getProjectDetailsById(
    projectID: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{projectID}/details"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/xml",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProjectDetailsById(_response)
      })
  }

  protected processGetProjectDetailsById(
    response: AxiosResponse,
  ): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid ID supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException(
        "project not found",
        status,
        _responseText,
        _headers,
      )
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<Project>(<any>null)
  }

  /**
   * Creates a new Deployment
   * @param body project object that needs to be added to the store
   */
  createDeployment(
    body: Project,
    projectID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/project/{projectID}/deployment/create"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateDeployment(_response)
      })
  }

  protected processCreateDeployment(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 405) {
      const _responseText = response.data
      return throwException("Invalid input", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Get all Deployments for an user
   * @param projectID ID of project to return
   * @return successful operation
   */
  getAllDeployments(
    projectID: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{projectID}/deployments"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllDeployments(_response)
      })
  }

  protected processGetAllDeployments(
    response: AxiosResponse,
  ): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid username supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException("User not found", status, _responseText, _headers)
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<Project>(<any>null)
  }

  /**
   * Get one Deployment
   * @return successful operation
   */
  getDeploymentById(
    projectID: string,
    deploymentID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{projectID}/deployment/{deploymentID}"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    if (deploymentID === undefined || deploymentID === null)
      throw new Error("The parameter 'deploymentID' must be defined.")
    url_ = url_.replace("{deploymentID}", encodeURIComponent("" + deploymentID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/xml",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeploymentById(_response)
      })
  }

  protected processGetDeploymentById(
    response: AxiosResponse,
  ): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid ID supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException(
        "project not found",
        status,
        _responseText,
        _headers,
      )
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<Project>(<any>null)
  }

  /**
   * Deletes a Deployment
   */
  deleteDeployment(
    projectID: string,
    deploymentID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/project/{projectID}/deployment/{deploymentID}"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    if (deploymentID === undefined || deploymentID === null)
      throw new Error("The parameter 'deploymentID' must be defined.")
    url_ = url_.replace("{deploymentID}", encodeURIComponent("" + deploymentID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteDeployment(_response)
      })
  }

  protected processDeleteDeployment(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid ID supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException(
        "project not found",
        status,
        _responseText,
        _headers,
      )
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<void>(<any>null)
  }

  /**
   * Get Deployment status
   * @return successful operation
   */
  getDeploymentStatus(
    projectID: string,
    deploymentID: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ =
      this.baseUrl + "/project/{projectID}/deployment/{deploymentID}/status"
    if (projectID === undefined || projectID === null)
      throw new Error("The parameter 'projectID' must be defined.")
    url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID))
    if (deploymentID === undefined || deploymentID === null)
      throw new Error("The parameter 'deploymentID' must be defined.")
    url_ = url_.replace("{deploymentID}", encodeURIComponent("" + deploymentID))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeploymentStatus(_response)
      })
  }

  protected processGetDeploymentStatus(
    response: AxiosResponse,
  ): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      return throwException(
        "Invalid ID supplied",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      return throwException(
        "project not found",
        status,
        _responseText,
        _headers,
      )
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers,
      )
    }
    return Promise.resolve<Project>(<any>null)
  }
}

export interface User {
  id?: number
  username?: string
  firstName?: string
  lastName?: string
  email?: string
  password?: string
  bearer_token?: string
}

export interface Order {
  id?: number
  projectId?: number
  quantity?: number
  shipDate?: Date
  /** Order Status */
  status?: OrderStatus
  complete?: boolean
}

export interface Category {
  id?: number
  name?: string
}

export interface Tag {
  id?: number
  name?: string
}

export interface Project {
  id?: number
  category?: Category
  name: string
  photoUrls: string[]
  tags?: Tag[]
  /** project status in the store */
  status?: ProjectStatus
}

export interface ApiResponse {
  code?: number
  type?: string
  message?: string
}

export enum OrderStatus {
  Placed = "placed",
  Approved = "approved",
  Delivered = "delivered",
}

export enum ProjectStatus {
  Available = "available",
  Pending = "pending",
  Sold = "sold",
}

export class ApiException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isApiException = true

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result
  else throw new ApiException(message, status, response, headers, null)
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true
}
