/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios"

export class AuthorizedApiBase {
  protected accessToken: string

  protected constructor(_config: IConfig, accessToken: string = "") {
    this.accessToken = accessToken
  }

  protected transformOptions = (
    options: AxiosRequestConfig,
  ): Promise<AxiosRequestConfig> => {
    options.headers = {
      ...options.headers,
      Authorization: this.accessToken ? `Bearer ${this.accessToken}` : "",
    }
    return Promise.resolve(options)
  }

  setToken(accessToken: string) {
    this.accessToken = accessToken
  }
}

export interface IImployApiClient {
  /**
   * Private Endpoint for Status Checks
   * @return successful operation
   */
  healthCheck(): Promise<void>
  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  loginUser(body: Login): Promise<AccessRefreshTokens>
  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(body: UserSignUp): Promise<User>
  /**
   * Redirects to the oauth2 providers permission address
   * @param provider The oauth2 provider name
   * @return successful operation
   */
  getOauth2Provider(provider: Provider): Promise<Oauth2RedirectResponse>
  /**
   * Generated token after validating oauth2 code
   * @return successful operation
   */
  postOauth2CodeGithub(
    code: string,
    state: string,
  ): Promise<AccessRefreshTokens>
  /**
   * Generated token after validating oauth2 code
   * @param scope (optional)
   * @param authUser (optional)
   * @param hd (optional)
   * @param prompt (optional)
   * @return successful operation
   */
  postOauth2CodeGoogle(
    code: string,
    state: string,
    scope?: string | undefined,
    authUser?: string | undefined,
    hd?: string | undefined,
    prompt?: string | undefined,
  ): Promise<AccessRefreshTokens>
  /**
   * Generated token after validating oauth2 code
   * @return successful operation
   */
  postOauth2CodeFacebook(
    code: string,
    state: string,
  ): Promise<AccessRefreshTokens>
  /**
   * Get User Data based on Bearer Token
   * @return successful operation
   */
  getUser(): Promise<User>
  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updateUser(body: UserPatch): Promise<User>
  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(): Promise<void>
  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  postNewEmailVerify(body: VerifyEmailToken): Promise<void>
  /**
   * Refreshes a set of tokens given a valid Refresh Token
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  getRefreshToken(token: string): Promise<AccessRefreshTokens>
  /**
   * Generate a challenge for the user to sign
   * @return Successful Operation
   */
  getWeb3Token(): Promise<Web3Login>
  /**
   * Autenticate using a signed web3 message
   * @param body (optional)
   * @return Successful Operation
   */
  postWeb3Token(
    body?: Web3RequestToken | undefined,
  ): Promise<AccessRefreshTokens>
  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation
   */
  addCard(body: AddCardRequest): Promise<FileResponse>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  updateDefaultCard(body: CardID): Promise<FileResponse>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  getDefaultCard(): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation
   */
  deleteCard(id: number): Promise<FileResponse>
  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getCard(id: number): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation
   */
  getAllCards(): Promise<CardInfo[]>
  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation
   */
  getAllInvoices(): Promise<InvoiceInfo[]>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation
   */
  getSubscription(id: number): Promise<FileResponse>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation
   */
  getAllSubscriptions(): Promise<SubscriptionInfo[]>
  /**
   * uploads a one or more files
   * @param files (optional)
   * @param path (optional)
   * @param deal_duration (optional)
   * @param replication (optional)
   * @return Successful Operation
   */
  addFPSFiles(
    files?: FileParameter[] | undefined,
    path?: string | undefined,
    deal_duration?: number | undefined,
    replication?: number | undefined,
  ): Promise<FilesUploadResponse>
  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveFPSObject(body: FilesMvRequest): Promise<void>
  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getFPSFileInfo(body: FilesPathRequest): Promise<FPSFilesFullinfoResponse>
  /**
   * removes a files or empty directories
   * @param body array of object paths
   * @return Successful Operation
   */
  removeFPSObjects(body: FilesRmRequest): Promise<void>
  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getFPSChildList(body: FilesPathRequest): Promise<FileContentResponse[]>
  /**
   * creates new directory
   * @param body directory path
   * @return Successful Operation
   */
  addFPSDirectory(body: FilesPathRequest): Promise<FileContentResponse>
  /**
   * get pin object info
   * @param pin_id pin object identifier
   * @return Successful Operation,
   */
  getPinsByID(pin_id: string): Promise<PinObject>
  /**
   * delete the pin object
   * @param pin_id pin object identifier
   * @return Successful Operation
   */
  deletePinByID(pin_id: string): Promise<void>
  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  updatePin(pin_id: string, body: ModifyPinRequest): Promise<PinObject>
  /**
   * add pin pins
   * @param body words go here
   * @return Successful Operation
   */
  addPin(body: AddPinsRequest): Promise<ListPinObjectResponse>
  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  getAllPins(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
  ): Promise<ListPinObjectResponse>
  /**
   * retrieve asks
   * @return Successful Operation
   */
  getAsks(): Promise<AskIndex>
  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation
   */
  getDeals(direction: Direction, only?: Only | undefined): Promise<DealRecord>
  /**
   * retrieve faults
   * @return Successful Operation
   */
  getFaults(): Promise<FaultsIndexSnapshot>
  /**
   * retrieve miners
   * @return Successful Operation
   */
  getMiners(): Promise<FileResponse>
  /**
   * retrieve peers
   * @return Successful Operation
   */
  getPeers(): Promise<FileResponse>
  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation
   */
  getTopMiners(limit: number): Promise<Anonymous2[]>
  /**
   * returns common Files/FPS store info like consumed sizes per Files and FPS service, deafult FIL wallet etc.
   * @return Successful Operation
   */
  getFilesStoreInfo(): Promise<FilesStoreInfoResponse>
  /**
   * retrieve content of file sotred in ChainSafe Files Service
   * @param body file path
   * @return Successful Operation
   */
  getFileContent(body: FilesPathRequest): Promise<void>
  /**
   * uploads a one or more files
   * @param file (optional)
   * @param path (optional)
   * @return Successful Operation
   */
  addCSFFiles(
    file?: FileParameter | undefined,
    path?: string | undefined,
  ): Promise<FilesUploadResponse>
  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveCSFObject(body: FilesMvRequest): Promise<void>
  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getCSFFileInfo(body: FilesPathRequest): Promise<CSFFilesFullinfoResponse>
  /**
   * removes a files or empty directories
   * @param body array of object paths
   * @return Successful Operation
   */
  removeCSFObjects(body: FilesRmRequest): Promise<void>
  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getCSFChildList(body: FilesPathRequest): Promise<FileContentResponse[]>
  /**
   * creates new directory
   * @param body directory path
   * @return Successful Operation
   */
  addCSFDirectory(body: FilesPathRequest): Promise<FileContentResponse>
}

export class ImployApiClient
  extends AuthorizedApiBase
  implements IImployApiClient {
  private instance: AxiosInstance
  private baseUrl: string
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration)
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl ? baseUrl : "https://stage.api.chainsafe.site"
  }

  /**
   * Private Endpoint for Status Checks
   * @return successful operation
   */
  healthCheck(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/status"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processHealthCheck(_response)
      })
  }

  protected processHealthCheck(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else {
      const _responseText = response.data
      return throwException("server error", status, _responseText, _headers)
    }
  }

  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  loginUser(
    body: Login,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLoginUser(_response)
      })
  }

  protected processLoginUser(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid username/password supplied",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(
    body: UserSignUp,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user/signup"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSignup(_response)
      })
  }

  protected processSignup(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Bad Request Binding",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Bad Request Password Not Matching",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Bad Request Email Already Exists",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Redirects to the oauth2 providers permission address
   * @param provider The oauth2 provider name
   * @return successful operation
   */
  getOauth2Provider(
    provider: Provider,
    cancelToken?: CancelToken | undefined,
  ): Promise<Oauth2RedirectResponse> {
    let url_ = this.baseUrl + "/user/auth/{provider}"
    if (provider === undefined || provider === null)
      throw new Error("The parameter 'provider' must be defined.")
    url_ = url_.replace("{provider}", encodeURIComponent("" + provider))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetOauth2Provider(_response)
      })
  }

  protected processGetOauth2Provider(
    response: AxiosResponse,
  ): Promise<Oauth2RedirectResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid provider supplied",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Generated token after validating oauth2 code
   * @return successful operation
   */
  postOauth2CodeGithub(
    code: string,
    state: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/auth/github/callback?"
    if (code === undefined || code === null)
      throw new Error(
        "The parameter 'code' must be defined and cannot be null.",
      )
    else url_ += "code=" + encodeURIComponent("" + code) + "&"
    if (state === undefined || state === null)
      throw new Error(
        "The parameter 'state' must be defined and cannot be null.",
      )
    else url_ += "state=" + encodeURIComponent("" + state) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostOauth2CodeGithub(_response)
      })
  }

  protected processPostOauth2CodeGithub(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid provider supplied",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid oauth2 code supplied",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Generated token after validating oauth2 code
   * @param scope (optional)
   * @param authUser (optional)
   * @param hd (optional)
   * @param prompt (optional)
   * @return successful operation
   */
  postOauth2CodeGoogle(
    code: string,
    state: string,
    scope?: string | undefined,
    authUser?: string | undefined,
    hd?: string | undefined,
    prompt?: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/auth/google/callback?"
    if (code === undefined || code === null)
      throw new Error(
        "The parameter 'code' must be defined and cannot be null.",
      )
    else url_ += "code=" + encodeURIComponent("" + code) + "&"
    if (state === undefined || state === null)
      throw new Error(
        "The parameter 'state' must be defined and cannot be null.",
      )
    else url_ += "state=" + encodeURIComponent("" + state) + "&"
    if (scope === null) throw new Error("The parameter 'scope' cannot be null.")
    else if (scope !== undefined)
      url_ += "scope=" + encodeURIComponent("" + scope) + "&"
    if (authUser === null)
      throw new Error("The parameter 'authUser' cannot be null.")
    else if (authUser !== undefined)
      url_ += "authUser=" + encodeURIComponent("" + authUser) + "&"
    if (hd === null) throw new Error("The parameter 'hd' cannot be null.")
    else if (hd !== undefined) url_ += "hd=" + encodeURIComponent("" + hd) + "&"
    if (prompt === null)
      throw new Error("The parameter 'prompt' cannot be null.")
    else if (prompt !== undefined)
      url_ += "prompt=" + encodeURIComponent("" + prompt) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostOauth2CodeGoogle(_response)
      })
  }

  protected processPostOauth2CodeGoogle(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid provider supplied",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid oauth2 code supplied",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Generated token after validating oauth2 code
   * @return successful operation
   */
  postOauth2CodeFacebook(
    code: string,
    state: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/auth/facebook/callback?"
    if (code === undefined || code === null)
      throw new Error(
        "The parameter 'code' must be defined and cannot be null.",
      )
    else url_ += "code=" + encodeURIComponent("" + code) + "&"
    if (state === undefined || state === null)
      throw new Error(
        "The parameter 'state' must be defined and cannot be null.",
      )
    else url_ += "state=" + encodeURIComponent("" + state) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostOauth2CodeFacebook(_response)
      })
  }

  protected processPostOauth2CodeFacebook(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid provider supplied",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid oauth2 code supplied",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Get User Data based on Bearer Token
   * @return successful operation
   */
  getUser(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/user/profile"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUser(_response)
      })
  }

  protected processGetUser(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updateUser(
    body: UserPatch,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user/profile"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateUser(_response)
      })
  }

  protected processUpdateUser(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email Verification sent recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "User with this email, phone number or username already exists",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetEmailVerify(_response)
      })
  }

  protected processGetEmailVerify(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Email already verified",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email sent recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  postNewEmailVerify(
    body: VerifyEmailToken,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostNewEmailVerify(_response)
      })
  }

  protected processPostNewEmailVerify(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "Confirmation or reset token expired",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email already verified",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Refreshes a set of tokens given a valid Refresh Token
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  getRefreshToken(
    token: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/refresh/{token}"
    if (token === undefined || token === null)
      throw new Error("The parameter 'token' must be defined.")
    url_ = url_.replace("{token}", encodeURIComponent("" + token))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRefreshToken(_response)
      })
  }

  protected processGetRefreshToken(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Generate a challenge for the user to sign
   * @return Successful Operation
   */
  getWeb3Token(cancelToken?: CancelToken | undefined): Promise<Web3Login> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetWeb3Token(_response)
      })
  }

  protected processGetWeb3Token(response: AxiosResponse): Promise<Web3Login> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Autenticate using a signed web3 message
   * @param body (optional)
   * @return Successful Operation
   */
  postWeb3Token(
    body?: Web3RequestToken | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostWeb3Token(_response)
      })
  }

  protected processPostWeb3Token(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "The provided signature, confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation
   */
  addCard(
    body: AddCardRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/billing/card/add"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      responseType: "blob",
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddCard(_response)
      })
  }

  protected processAddCard(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      })
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid card",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  updateDefaultCard(
    body: CardID,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      responseType: "blob",
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateDefaultCard(_response)
      })
  }

  protected processUpdateDefaultCard(
    response: AxiosResponse,
  ): Promise<FileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      })
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid card id",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  getDefaultCard(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDefaultCard(_response)
      })
  }

  protected processGetDefaultCard(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation
   */
  deleteCard(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteCard(_response)
      })
  }

  protected processDeleteCard(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      })
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid card id",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getCard(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetCard(_response)
      })
  }

  protected processGetCard(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation
   */
  getAllCards(cancelToken?: CancelToken | undefined): Promise<CardInfo[]> {
    let url_ = this.baseUrl + "/billing/cards"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllCards(_response)
      })
  }

  protected processGetAllCards(response: AxiosResponse): Promise<CardInfo[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation
   */
  getAllInvoices(
    cancelToken?: CancelToken | undefined,
  ): Promise<InvoiceInfo[]> {
    let url_ = this.baseUrl + "/billing/invoices"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllInvoices(_response)
      })
  }

  protected processGetAllInvoices(
    response: AxiosResponse,
  ): Promise<InvoiceInfo[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation
   */
  getSubscription(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/billing/subscription/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSubscription(_response)
      })
  }

  protected processGetSubscription(
    response: AxiosResponse,
  ): Promise<FileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      })
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "subscription not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation
   */
  getAllSubscriptions(
    cancelToken?: CancelToken | undefined,
  ): Promise<SubscriptionInfo[]> {
    let url_ = this.baseUrl + "/billing/subscriptions"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllSubscriptions(_response)
      })
  }

  protected processGetAllSubscriptions(
    response: AxiosResponse,
  ): Promise<SubscriptionInfo[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * uploads a one or more files
   * @param files (optional)
   * @param path (optional)
   * @param deal_duration (optional)
   * @param replication (optional)
   * @return Successful Operation
   */
  addFPSFiles(
    files?: FileParameter[] | undefined,
    path?: string | undefined,
    deal_duration?: number | undefined,
    replication?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<FilesUploadResponse> {
    let url_ = this.baseUrl + "/fps/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (files === null || files === undefined)
      throw new Error("The parameter 'files' cannot be null.")
    else
      files.forEach((item_) =>
        content_.append(
          "files",
          item_.data,
          item_.fileName ? item_.fileName : "files",
        ),
      )
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())
    if (deal_duration === null || deal_duration === undefined)
      throw new Error("The parameter 'deal_duration' cannot be null.")
    else content_.append("deal_duration", deal_duration.toString())
    if (replication === null || replication === undefined)
      throw new Error("The parameter 'replication' cannot be null.")
    else content_.append("replication", replication.toString())

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddFPSFiles(_response)
      })
  }

  protected processAddFPSFiles(
    response: AxiosResponse,
  ): Promise<FilesUploadResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveFPSObject(
    body: FilesMvRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/mv"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processMoveFPSObject(_response)
      })
  }

  protected processMoveFPSObject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File Name do not exists for the provided user",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getFPSFileInfo(
    body: FilesPathRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<FPSFilesFullinfoResponse> {
    let url_ = this.baseUrl + "/fps/file"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFPSFileInfo(_response)
      })
  }

  protected processGetFPSFileInfo(
    response: AxiosResponse,
  ): Promise<FPSFilesFullinfoResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "File Store or File itself do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * removes a files or empty directories
   * @param body array of object paths
   * @return Successful Operation
   */
  removeFPSObjects(
    body: FilesRmRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/rm"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRemoveFPSObjects(_response)
      })
  }

  protected processRemoveFPSObjects(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "Drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getFPSChildList(
    body: FilesPathRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileContentResponse[]> {
    let url_ = this.baseUrl + "/fps/ls"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFPSChildList(_response)
      })
  }

  protected processGetFPSChildList(
    response: AxiosResponse,
  ): Promise<FileContentResponse[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * creates new directory
   * @param body directory path
   * @return Successful Operation
   */
  addFPSDirectory(
    body: FilesPathRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileContentResponse> {
    let url_ = this.baseUrl + "/fps/mkdir"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddFPSDirectory(_response)
      })
  }

  protected processAddFPSDirectory(
    response: AxiosResponse,
  ): Promise<FileContentResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * get pin object info
   * @param pin_id pin object identifier
   * @return Successful Operation,
   */
  getPinsByID(
    pin_id: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<PinObject> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPinsByID(_response)
      })
  }

  protected processGetPinsByID(response: AxiosResponse): Promise<PinObject> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing authorization token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "no pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * delete the pin object
   * @param pin_id pin object identifier
   * @return Successful Operation
   */
  deletePinByID(
    pin_id: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeletePinByID(_response)
      })
  }

  protected processDeletePinByID(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  updatePin(
    pin_id: string,
    body: ModifyPinRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<PinObject> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdatePin(_response)
      })
  }

  protected processUpdatePin(response: AxiosResponse): Promise<PinObject> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "No pin data was provider for modification",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * add pin pins
   * @param body words go here
   * @return Successful Operation
   */
  addPin(
    body: AddPinsRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<ListPinObjectResponse> {
    let url_ = this.baseUrl + "/fps/pins"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddPin(_response)
      })
  }

  protected processAddPin(
    response: AxiosResponse,
  ): Promise<ListPinObjectResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "no pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  getAllPins(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<ListPinObjectResponse> {
    let url_ = this.baseUrl + "/fps/pins?"
    if (status === null)
      throw new Error("The parameter 'status' cannot be null.")
    else if (status !== undefined)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    if (limit === null) throw new Error("The parameter 'limit' cannot be null.")
    else if (limit !== undefined)
      url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    if (cid === null) throw new Error("The parameter 'cid' cannot be null.")
    else if (cid !== undefined)
      url_ += "cid=" + encodeURIComponent("" + cid) + "&"
    if (before === null)
      throw new Error("The parameter 'before' cannot be null.")
    else if (before !== undefined)
      url_ += "before=" + encodeURIComponent("" + before) + "&"
    if (after === null) throw new Error("The parameter 'after' cannot be null.")
    else if (after !== undefined)
      url_ += "after=" + encodeURIComponent("" + after) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllPins(_response)
      })
  }

  protected processGetAllPins(
    response: AxiosResponse,
  ): Promise<ListPinObjectResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "max limit of returned pin objects is 1000 and min is 1",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve asks
   * @return Successful Operation
   */
  getAsks(cancelToken?: CancelToken | undefined): Promise<AskIndex> {
    let url_ = this.baseUrl + "/powergate/asks"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAsks(_response)
      })
  }

  protected processGetAsks(response: AxiosResponse): Promise<AskIndex> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation
   */
  getDeals(
    direction: Direction,
    only?: Only | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<DealRecord> {
    let url_ = this.baseUrl + "/powergate/deals?"
    if (direction === undefined || direction === null)
      throw new Error(
        "The parameter 'direction' must be defined and cannot be null.",
      )
    else url_ += "direction=" + encodeURIComponent("" + direction) + "&"
    if (only === null) throw new Error("The parameter 'only' cannot be null.")
    else if (only !== undefined)
      url_ += "only=" + encodeURIComponent("" + only) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeals(_response)
      })
  }

  protected processGetDeals(response: AxiosResponse): Promise<DealRecord> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer tokeng",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "no direction query parameter was provided in a request",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve faults
   * @return Successful Operation
   */
  getFaults(
    cancelToken?: CancelToken | undefined,
  ): Promise<FaultsIndexSnapshot> {
    let url_ = this.baseUrl + "/powergate/faults"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFaults(_response)
      })
  }

  protected processGetFaults(
    response: AxiosResponse,
  ): Promise<FaultsIndexSnapshot> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "no direction query parameter was provided in a request",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve miners
   * @return Successful Operation
   */
  getMiners(cancelToken?: CancelToken | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/powergate/miners"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetMiners(_response)
      })
  }

  protected processGetMiners(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      })
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve peers
   * @return Successful Operation
   */
  getPeers(cancelToken?: CancelToken | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/powergate/peers"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPeers(_response)
      })
  }

  protected processGetPeers(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      })
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation
   */
  getTopMiners(
    limit: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous2[]> {
    let url_ = this.baseUrl + "/powergate/reputation/topminers?"
    if (limit === undefined || limit === null)
      throw new Error(
        "The parameter 'limit' must be defined and cannot be null.",
      )
    else url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTopMiners(_response)
      })
  }

  protected processGetTopMiners(
    response: AxiosResponse,
  ): Promise<Anonymous2[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "provided limit is invalid",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * returns common Files/FPS store info like consumed sizes per Files and FPS service, deafult FIL wallet etc.
   * @return Successful Operation
   */
  getFilesStoreInfo(
    cancelToken?: CancelToken | undefined,
  ): Promise<FilesStoreInfoResponse> {
    let url_ = this.baseUrl + "/files/info"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFilesStoreInfo(_response)
      })
  }

  protected processGetFilesStoreInfo(
    response: AxiosResponse,
  ): Promise<FilesStoreInfoResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "File of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "Drive Service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve content of file sotred in ChainSafe Files Service
   * @param body file path
   * @return Successful Operation
   */
  getFileContent(
    body: FilesPathRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/files/download"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFileContent(_response)
      })
  }

  protected processGetFileContent(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File with such CID does not exists",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * uploads a one or more files
   * @param file (optional)
   * @param path (optional)
   * @return Successful Operation
   */
  addCSFFiles(
    file?: FileParameter | undefined,
    path?: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<FilesUploadResponse> {
    let url_ = this.baseUrl + "/files/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.")
    else
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddCSFFiles(_response)
      })
  }

  protected processAddCSFFiles(
    response: AxiosResponse,
  ): Promise<FilesUploadResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveCSFObject(
    body: FilesMvRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/files/mv"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processMoveCSFObject(_response)
      })
  }

  protected processMoveCSFObject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File Name do not exists for the provided user",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getCSFFileInfo(
    body: FilesPathRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<CSFFilesFullinfoResponse> {
    let url_ = this.baseUrl + "/files/file"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetCSFFileInfo(_response)
      })
  }

  protected processGetCSFFileInfo(
    response: AxiosResponse,
  ): Promise<CSFFilesFullinfoResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "File Store or File itself do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * removes a files or empty directories
   * @param body array of object paths
   * @return Successful Operation
   */
  removeCSFObjects(
    body: FilesRmRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/files/rm"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRemoveCSFObjects(_response)
      })
  }

  protected processRemoveCSFObjects(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "Drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getCSFChildList(
    body: FilesPathRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileContentResponse[]> {
    let url_ = this.baseUrl + "/files/ls"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetCSFChildList(_response)
      })
  }

  protected processGetCSFChildList(
    response: AxiosResponse,
  ): Promise<FileContentResponse[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * creates new directory
   * @param body directory path
   * @return Successful Operation
   */
  addCSFDirectory(
    body: FilesPathRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileContentResponse> {
    let url_ = this.baseUrl + "/files/mkdir"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddCSFDirectory(_response)
      })
  }

  protected processAddCSFDirectory(
    response: AxiosResponse,
  ): Promise<FileContentResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }
}

export interface FilesStoreInfoResponse {
  /** User Powergate FFS instance identifier */
  ffs_instance?: string
  /** size of the user's ChainSafe File Store in bytes */
  csf_size?: number
  /** size of the user's File Pinning Service in bytes */
  fps_size?: number
  /** user FIL wallet deatils */
  wallets?: Wallets
  /** api key used for access */
  api_key?: string
}

export interface CSFFilesFullinfoResponse {
  content?: FileContentResponse
  persistent?: CSFPesistentResponse
  /** list of messages containig warnings and errors about File Coin deals that filed */
  messages?: string[]
}

export interface FPSFilesFullinfoResponse {
  content?: FileContentResponse
  persistent?: FPSPesistentResponse
  /** list of messages containig warnings and errors about File Coin deals that filed */
  messages?: string[]
}

/** information about storage options for the Files object in question */
export interface CSFPesistentResponse {
  /** time what file was uploaded */
  uploaded?: number
  /** time what file land on storage layer after all deals */
  saved_time?: number
  /** size of encrypted file in bytes, differ from content size because of it */
  stored_size?: number
  /** cid of the sored file in ipfs, usaully the same as cid in content section */
  stored_cid?: string
}

/** information about storage options for the Files object in question */
export interface FPSPesistentResponse {
  /** time what file was uploaded */
  uploaded?: number
  /** time what file land on storage layer after all deals */
  saved_time?: number
  /** size of stored file in bytes */
  stored_size?: number
  /** cid of the sored file in ipfs, usaully the same as cid in content section */
  stored_cid?: string
  /** File Coin storage details */
  filecoin?: Filecoin
}

/** service specific Files object info */
export interface FileContentResponse {
  /** File or Flder object name */
  name: string
  /** File or Folder content identifier */
  cid: string
  /** mime type that described files object */
  type: string
  /** size of the file */
  size: number
  /** content type */
  content_type: string
}

export interface FilesPathRequest {
  /** path to the file object */
  path: string
}

export interface FilesMvRequest {
  /** path to the file object */
  path: string
  /** desired new path file object needs to be moved */
  new_path: string
}

export interface FilesRmRequest {
  /** list of paths to the file objects that needs to be deleted */
  paths: any[]
}

export interface FilesUploadResponse {
  /** path where all uploaded files are placed */
  path: string
}

export interface ModifyPinRequest {
  pins?: Pin
  deal?: Deal
}

export interface AddPinsRequest {
  /** list of pins that needs to be added */
  pins?: Pin[]
  deal?: Deal
}

export interface ListPinObjectResponse {
  /** number of returned items */
  count?: number
  /** list of pin objects created as a resuls of pinning cids */
  results?: PinObject[]
}

export interface PinObject {
  /** pin object identifier */
  id?: string
  /** date and time of pin object creation */
  created?: Date
  /** current status of pinned object */
  status?: PinObjectStatus
  /** list of providers in which returned cid can be found */
  delegates?: string[]
  pin?: Pin
  deal?: Deal
}

/** the pin */
export interface Pin {
  /** file identification number */
  cid?: string
  /** list of providers hints provided by user on the time of pinning */
  origins?: string[]
}

/** desired File Coin deal properties */
export interface Deal {
  /** deal duration in seonds */
  deal_duration?: number
  /** number of desired file instances */
  replication?: number
}

export interface AskIndex {
  /** date last updated_at */
  lastupdated?: string
  /** storeage median price */
  storagemedianprice?: number
  /** information about the storage ask */
  storage?: any
}

/** record for current deal */
export interface DealRecord {}

/** index snapshot with map of miners and faults */
export interface FaultsIndexSnapshot {}

/** index snapshot miners info */
export interface MinerIndexSnapshot {}

/** info about peers including network and location data */
export interface PeerInfo {}

export interface Login {
  /** Email Address of the user */
  email: string
  /** Password of the user */
  password: string
}

export interface Token {
  /** Authentication token used for api access */
  token?: string
  /** The Expiration date of the token */
  expires?: string
}

export interface AccessRefreshTokens {
  /** Authentication Token used for API access */
  access_token?: any
  /** Refresh Token used for API access */
  refresh_token?: any
}

export interface UserSignUp {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Password of the User */
  password: string
}

export interface UserPatch {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Email Address of the User */
  email: string
  /** UserName of the User */
  username?: string
  /** Phone Number of the User */
  phone?: string
  /** City of the User */
  city?: string
  /** Country of the User */
  country?: string
}

export interface User {
  /** Identification Number of the User */
  id?: number
  /** Timestamp of the User creation event */
  created_at?: string
  /** Timestamp of the last User last update */
  updated_at?: string
  /** Timestamp of the Users Delete event */
  deleted_at?: string
  /** The Universal Unique Identifier of the User */
  uuid?: string
  /** First Name of tne User */
  first_name?: string
  /** Last Name of the User */
  last_name?: string
  /** UserName of the User */
  username?: string
  /** Public Address of the User */
  public_address?: string
  /** Email Address of the User */
  email?: string
  /** Phone number of the User */
  phone?: string
  /** Is the User Active */
  active?: boolean
  /** Is the User Verified */
  verified?: boolean
  /** Is the User Payments Activated */
  payment_active?: boolean
  /** Timestamp of the Users last login */
  last_login?: string
  /** Timpstamp of the User's last password change */
  last_password_change?: string
  /** Timestamp of the User's last email change */
  last_email_change?: string
  /** IP address of the User's last login */
  login_ip?: string
  /** Timestamp of the last User login */
  login_at?: string
  /** Browser used by the User last */
  browser?: string
  /** City the User has registered */
  city?: string
  /** Country the User has registered */
  country?: string
}

export interface VerifyEmailToken {
  /** Identification Number of the User */
  id: number
  /** Authenticaton Token */
  token: string
}

export interface Oauth2RedirectResponse {
  /** The redirected to url of the Oauth2 provider */
  url: string
}

export interface Web3Login {
  /** Token from the */
  token?: string
  expires?: string
}

export interface Web3RequestToken {
  /** Public Address of the user */
  public_address?: string
  /** Token gotten from calling the web3 login API */
  token: string
  /** Signature of the Token generated using user's Private Key */
  signature: string
}

/** info about user's card, returns objects referenced here https://stripe.com/docs/api/cards/object */
export interface CardInfo {}

/** info about user's subscription, returns objects referenced here https://stripe.com/docs/api/subscription/object */
export interface SubscriptionInfo {}

/** invoice deatils, returns objects referenced here https://stripe.com/docs/api/invoices/object */
export interface InvoiceInfo {}

export interface AddCardRequest {
  /** card token returned from stripe */
  token: string
}

export interface CardID {
  /** id of the card that you want to perform an action on */
  id: number
}

export type Provider = "github" | "google" | "facebook" | "twitter"

export type Status = "queued" | "failed" | "pinning" | "pinned"

export type Direction = "retrieval" | "storage"

export type Only = "final" | "pending"

export interface Anonymous {
  /** The type or category of error */
  error_type?: string
  /** The error message */
  message?: string
}

export interface Anonymous2 {
  /** miner address */
  addr?: string
  /** miner current score */
  score?: number
}

export interface Wallets {
  /** name of the wallet, deafult one called "Initial Address" */
  name?: string
  /** wallet address */
  address?: string
  /** type of the wallet from FIL wallets perspective, default one is `bls` */
  type?: string
  /** current wallet balance */
  balance?: number
  /** any implortant information about that wallet, like warnings or erros, supplied by File Coin node */
  messgae?: string
}

export interface Filecoin {
  /** cid of the sotred onject in File Coin network */
  cid?: string
  /** size of sored data in File Coin network, usually quanted by minimum stored size */
  size?: number
  /** info about File Coin proposals */
  proposals?: Proposals[]
}

export type PinObjectStatus = "queued" | "pinning" | "pinned" | "failed"

export interface Proposals {
  /** cid of the proposal data */
  cid?: string
  /** deal duration in seonds */
  duration?: number
  /** activation epoch number */
  activation_epoch?: number
  /** start epoch number */
  start_epoch?: number
  /** responsible miner */
  miner?: string
  /** epoch price */
  epoch_price?: number
}

export interface FileParameter {
  data: any
  fileName: string
}

export interface FileResponse {
  data: Blob
  status: number
  fileName?: string
  headers?: { [name: string]: any }
}

export class ImployApiException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isImployApiException = true

  static isImployApiException(obj: any): obj is ImployApiException {
    return obj.isImployApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result
  else throw new ImployApiException(message, status, response, headers, null)
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true
}

/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
export class IConfig {
  /**
   * Returns a valid value for the Authorization header.
   * Used to dynamically inject the current auth header.
   */
}
