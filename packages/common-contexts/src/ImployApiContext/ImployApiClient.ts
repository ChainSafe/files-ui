/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios"

export class AuthorizedApiBase {
  protected accessToken: string
  //@ts-ignore
  private readonly config: IConfig

  protected constructor(config: IConfig, accessToken: string = "") {
    this.config = config
    this.accessToken = accessToken
  }

  protected transformOptions = (
    options: AxiosRequestConfig,
  ): Promise<AxiosRequestConfig> => {
    options.headers = {
      ...options.headers,
      Authorization: this.accessToken ? `Bearer ${this.accessToken}` : "",
    }
    return Promise.resolve(options)
  }

  setToken(accessToken: string) {
    this.accessToken = accessToken
  }
}

export interface IImployApiClient {
  /**
   * Private Endpoint for Status Checks
   * @return successful operation
   */
  healthCheck(): Promise<void>
  /**
   * Imploy Private Server Port Access Only - ViewOne Deployment
   * @param body Blockchain JSON-RPC Call
   * @return succesful operation
   */
  viewOneDeployment(
    chain: string,
    network: string,
    api: string,
    body: RPCRequest,
  ): Promise<Anonymous[]>
  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  loginUser(body: Login): Promise<AccessRefreshTokens>
  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(body: UserSignUp): Promise<User>
  /**
   * Get User Data based on Bearer Token
   * @return successful operation
   */
  getUser(): Promise<User>
  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updateUser(body: UserPatch): Promise<User>
  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(): Promise<void>
  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  postNewEmailVerify(body: VerifyEmailToken): Promise<void>
  /**
   * Refreshes a set of tokens given a valid Refresh Token
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  getRefreshToken(token: string): Promise<AccessRefreshTokens>
  /**
   * Generate a challenge for the user to sign
   * @return Successful Operation
   */
  getWeb3Token(): Promise<Web3Login>
  /**
   * Autenticate using a signed web3 message
   * @param body (optional)
   * @return Successful Operation
   */
  postWeb3Token(
    body?: Web3RequestToken | undefined,
  ): Promise<AccessRefreshTokens>
  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updatePassword(body: NewPassword): Promise<void>
  /**
   * Updates user info
   * @param email Email Address of the
   * @return Successful Operation
   */
  getResetPassword(email: string): Promise<void>
  /**
   * Complete the Password reset process
   * @param body Updated user object
   * @return Successful Operation
   */
  postPasswordReset(body: ResetPassword): Promise<void>
  /**
   * Complete a Password the Password reset process
   * @param body words go here
   * @return Successful Operation
   */
  postPasswordResetVerify(body: VerifyPasswordReset): Promise<void>
  /**
   * Creates a new project
   * @param body information about a project
   * @return Successful Operation
   */
  addproject(body: ProjectRequest): Promise<Project>
  /**
   * this operation soft deletes a project and no longer be visible to the user
   * @param id identification number of the project
   * @return Successful Operation
   */
  deleteproject(id: number): Promise<void>
  /**
   * put words here
   * @param id identification number of the project
   * @param body information about a project sent in a request
   * @return Successful Operation
   */
  updateproject(id: number, body: ProjectRequest): Promise<Project>
  /**
   * retrieves information about a specific project
   * @param id identification number of the project
   * @return Successful Operation
   */
  getProject(id: number): Promise<Project>
  /**
   * this operation retrieves all projects for a given user
   * @return an array of project objects
   */
  getallproject(): Promise<Project[]>
  /**
   * Deploy a blockchain environment
   * @param body information about a project
   * @return an array of project objects
   */
  addDeployment(body: NewDeploymentRequest): Promise<Deployment>
  /**
   * this operation deprovisions a deployed blockchain environment in AWS
   * @param id identification number of the deployment
   * @return Successful Operation
   */
  deletedeployment(id: number): Promise<void>
  /**
   * this operation retuns the status of an active deployment
   * @param id identification number of the deployment
   * @return Successful Operation.  Valid values areCreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12, Unhealthy = 13
   */
  getdeploymentstatus(id: number): Promise<number>
  /**
   * this operation returns an array of actve deployments
   * @param id identification number of the deployment
   * @return an array of deployment objects
   */
  getdeployments(id: number): Promise<Deployment[]>
  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  addCard(body: AddCardRequest): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  updateDefaultCard(body: CardID): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  getDefaultCard(): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  deleteCard(id: number): Promise<void>
  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getCard(id: number): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getAllCards(): Promise<void>
  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/invoices/object
   */
  getAllInvoices(): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getSubscription(id: number): Promise<void>
  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getAllSubscriptions(): Promise<void>
  /**
   * upload a bunch of files to the pin service
   * @param file (optional)
   * @param path (optional)
   * @param replication (optional)
   * @param deal_duration (optional)
   * @return Successful Operation
   */
  uploadPins(
    file?: any | undefined,
    path?: string | undefined,
    replication?: number | undefined,
    deal_duration?: boolean | undefined,
  ): Promise<void>
  /**
   * get pin object info
   * @param pin_id pin object cid
   * @return Successful Operation,
   */
  getPinsByCID(pin_id: string): Promise<Anonymous2>
  /**
   * delete the pin object
   * @param pin_id pin object cid
   * @return Successful Operation
   */
  deletePins(pin_id: string): Promise<void>
  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  updatePin(pin_id: string, body: Body): Promise<void>
  /**
   * add pin objects
   * @param body words go here
   * @return Successful Operation
   */
  addPin(body: Body2): Promise<void>
  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  getAllPins(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
  ): Promise<Anonymous3[]>
  /**
   * retrieve asks
   * @return Successful Operation returns objects referenced here  https://github.com/textileio/powergate/blob/master/index/ask/types.go
   */
  getAsks(): Promise<Anonymous4>
  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation returns a deal record object referenced here https://github.com/textileio/powergate/blob/master/deals/types.go
   */
  getDeals(direction: Direction, only?: Only | undefined): Promise<Anonymous5>
  /**
   * retrieve faults
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/faults/types.go
   */
  getFaults(): Promise<Anonymous6>
  /**
   * retrieve miners
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getMiners(): Promise<Anonymous7>
  /**
   * retrieve peers
   * @return Successful Operation returns objects referenced here hhttps://github.com/textileio/powergate/blob/master/net/interface.go
   */
  getPeers(): Promise<Anonymous8>
  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getTopMiners(api_key: string, limit: number): Promise<Anonymous9>
  /**
   * returns file store info
   * @return Successful Operation
   */
  getFileStoreInfo(): Promise<Anonymous10>
  /**
   * retrieve file content
   * @param body file path
   * @return Successful Operation
   */
  getFileContent(body: FileRequest): Promise<void>
  /**
   * uploads a file
   * @param file (optional)
   * @param path (optional)
   * @param type (optional)
   * @param update (optional)
   * @return Successful Operation
   */
  addFile(
    file?: FileParameter | undefined,
    path?: string | undefined,
    type?: string | undefined,
    update?: boolean | undefined,
  ): Promise<FileResponse>
  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveObject(body: FileRequest): Promise<void>
  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getFileInfo(body: FileRequest): Promise<void>
  /**
   * removes a file or empty directory
   * @param body file path
   * @return Successful Operation
   */
  removeObject(body: FileRequest): Promise<void>
  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getChildList(body: FileRequest): Promise<FileResponse[]>
  /**
   * creates new directory
   * @param body file path
   * @return Successful Operation
   */
  addDirectory(body: FileRequest): Promise<void>
}

export class ImployApiClient
  extends AuthorizedApiBase
  implements IImployApiClient {
  private instance: AxiosInstance
  private baseUrl: string
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration)
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl ? baseUrl : "https://stage.api.chainsafe.site"
  }

  /**
   * Private Endpoint for Status Checks
   * @return successful operation
   */
  healthCheck(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/status"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processHealthCheck(_response)
      })
  }

  protected processHealthCheck(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else {
      const _responseText = response.data
      return throwException("server error", status, _responseText, _headers)
    }
  }

  /**
   * Imploy Private Server Port Access Only - ViewOne Deployment
   * @param body Blockchain JSON-RPC Call
   * @return succesful operation
   */
  viewOneDeployment(
    chain: string,
    network: string,
    api: string,
    body: RPCRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous[]> {
    let url_ = this.baseUrl + "/{chain}/{network}/{api}"
    if (chain === undefined || chain === null)
      throw new Error("The parameter 'chain' must be defined.")
    url_ = url_.replace("{chain}", encodeURIComponent("" + chain))
    if (network === undefined || network === null)
      throw new Error("The parameter 'network' must be defined.")
    url_ = url_.replace("{network}", encodeURIComponent("" + network))
    if (api === undefined || api === null)
      throw new Error("The parameter 'api' must be defined.")
    url_ = url_.replace("{api}", encodeURIComponent("" + api))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "GET",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processViewOneDeployment(_response)
      })
  }

  protected processViewOneDeployment(
    response: AxiosResponse,
  ): Promise<Anonymous[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      let result401: any = null
      let resultData401 = _responseText
      result401 = JSON.parse(resultData401)
      return throwException(
        "unauthorized access",
        status,
        _responseText,
        _headers,
        result401,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Login user into the system
   * @param body Email for login and Password in clear text
   * @return successful operation
   */
  loginUser(
    body: Login,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLoginUser(_response)
      })
  }

  protected processLoginUser(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid username/password supplied",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Signup new user into the system
   * @param body Created user object
   * @return successful operation
   */
  signup(
    body: UserSignUp,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user/signup"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSignup(_response)
      })
  }

  protected processSignup(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Bad Request Binding",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Bad Request Password Not Matching",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Bad Request Email Already Exists",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Get User Data based on Bearer Token
   * @return successful operation
   */
  getUser(cancelToken?: CancelToken | undefined): Promise<User> {
    let url_ = this.baseUrl + "/user/"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUser(_response)
      })
  }

  protected processGetUser(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updateUser(
    body: UserPatch,
    cancelToken?: CancelToken | undefined,
  ): Promise<User> {
    let url_ = this.baseUrl + "/user/"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateUser(_response)
      })
  }

  protected processUpdateUser(response: AxiosResponse): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email Verification sent recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "User with this email, phone number or username already exists",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Get email verification link
   * @return successful operation
   */
  getEmailVerify(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetEmailVerify(_response)
      })
  }

  protected processGetEmailVerify(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Email already verified",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email sent recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Sends a new email verification link
   * @param body Updated user object
   * @return Successful Operation
   */
  postNewEmailVerify(
    body: VerifyEmailToken,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/email/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostNewEmailVerify(_response)
      })
  }

  protected processPostNewEmailVerify(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "Confirmation or reset token expired",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Email already verified",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Refreshes a set of tokens given a valid Refresh Token
   * @param token Refresh the expiration date of a token
   * @return successful operation
   */
  getRefreshToken(
    token: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/refresh/{token}"
    if (token === undefined || token === null)
      throw new Error("The parameter 'token' must be defined.")
    url_ = url_.replace("{token}", encodeURIComponent("" + token))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRefreshToken(_response)
      })
  }

  protected processGetRefreshToken(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Generate a challenge for the user to sign
   * @return Successful Operation
   */
  getWeb3Token(cancelToken?: CancelToken | undefined): Promise<Web3Login> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetWeb3Token(_response)
      })
  }

  protected processGetWeb3Token(response: AxiosResponse): Promise<Web3Login> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Autenticate using a signed web3 message
   * @param body (optional)
   * @return Successful Operation
   */
  postWeb3Token(
    body?: Web3RequestToken | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<AccessRefreshTokens> {
    let url_ = this.baseUrl + "/user/web3/login"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostWeb3Token(_response)
      })
  }

  protected processPostWeb3Token(
    response: AxiosResponse,
  ): Promise<AccessRefreshTokens> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "The provided signature, confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Updates user info
   * @param body Updated user object
   * @return Successful Operation
   */
  updatePassword(
    body: NewPassword,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/change"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdatePassword(_response)
      })
  }

  protected processUpdatePassword(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Password and confirm password do not match",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "New password is same as old password or incorrect old password",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "New password is weak",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Updates user info
   * @param email Email Address of the
   * @return Successful Operation
   */
  getResetPassword(
    email: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset/{email}"
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.")
    url_ = url_.replace("{email}", encodeURIComponent("" + email))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetResetPassword(_response)
      })
  }

  protected processGetResetPassword(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No user found With this email",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Reset Email sent Recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Complete the Password reset process
   * @param body Updated user object
   * @return Successful Operation
   */
  postPasswordReset(
    body: ResetPassword,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostPasswordReset(_response)
      })
  }

  protected processPostPasswordReset(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Password and confirm password do not match",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Reset Email sent Recently",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "Confirmation or reset token expired",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Complete a Password the Password reset process
   * @param body words go here
   * @return Successful Operation
   */
  postPasswordResetVerify(
    body: VerifyPasswordReset,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/user/password/reset/verify"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPostPasswordResetVerify(_response)
      })
  }

  protected processPostPasswordResetVerify(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Confirmation or reset token is invalid",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "Confirmation or reset token expired",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Creates a new project
   * @param body information about a project
   * @return Successful Operation
   */
  addproject(
    body: ProjectRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/create"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddproject(_response)
      })
  }

  protected processAddproject(response: AxiosResponse): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "Maximum project creation limit for a user reached",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Project with same name already exists",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation soft deletes a project and no longer be visible to the user
   * @param id identification number of the project
   * @return Successful Operation
   */
  deleteproject(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteproject(_response)
      })
  }

  protected processDeleteproject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested project not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @param id identification number of the project
   * @param body information about a project sent in a request
   * @return Successful Operation
   */
  updateproject(
    id: number,
    body: ProjectRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateproject(_response)
      })
  }

  protected processUpdateproject(response: AxiosResponse): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "project does not exist",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "project with the same name already exists",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieves information about a specific project
   * @param id identification number of the project
   * @return Successful Operation
   */
  getProject(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Project> {
    let url_ = this.baseUrl + "/project/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProject(_response)
      })
  }

  protected processGetProject(response: AxiosResponse): Promise<Project> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "requested project not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation retrieves all projects for a given user
   * @return an array of project objects
   */
  getallproject(cancelToken?: CancelToken | undefined): Promise<Project[]> {
    let url_ = this.baseUrl + "/projects"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetallproject(_response)
      })
  }

  protected processGetallproject(response: AxiosResponse): Promise<Project[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * Deploy a blockchain environment
   * @param body information about a project
   * @return an array of project objects
   */
  addDeployment(
    body: NewDeploymentRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<Deployment> {
    let url_ = this.baseUrl + "/deployment/create"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddDeployment(_response)
      })
  }

  protected processAddDeployment(response: AxiosResponse): Promise<Deployment> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested project not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 412) {
      const _responseText = response.data
      let result412: any = null
      let resultData412 = _responseText
      result412 = JSON.parse(resultData412)
      return throwException(
        "user's email is not verified or No payment method added before deploying nodes",
        status,
        _responseText,
        _headers,
        result412,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending or Non existing params for deployment",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation deprovisions a deployed blockchain environment in AWS
   * @param id identification number of the deployment
   * @return Successful Operation
   */
  deletedeployment(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/deployment/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeletedeployment(_response)
      })
  }

  protected processDeletedeployment(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested deployment not found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "Invalid action. Similar kind of action or dependent action already in pending",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation retuns the status of an active deployment
   * @param id identification number of the deployment
   * @return Successful Operation.  Valid values areCreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12, Unhealthy = 13
   */
  getdeploymentstatus(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<number> {
    let url_ = this.baseUrl + "/deployment/{id}/status"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetdeploymentstatus(_response)
      })
  }

  protected processGetdeploymentstatus(
    response: AxiosResponse,
  ): Promise<number> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Requested deployment not exists for the user",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * this operation returns an array of actve deployments
   * @param id identification number of the deployment
   * @return an array of deployment objects
   */
  getdeployments(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Deployment[]> {
    let url_ = this.baseUrl + "/project/{id}/deployments"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetdeployments(_response)
      })
  }

  protected processGetdeployments(
    response: AxiosResponse,
  ): Promise<Deployment[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd party stripe api
   * @param body the credit card token id
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  addCard(
    body: AddCardRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/add"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddCard(_response)
      })
  }

  protected processAddCard(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 403) {
      const _responseText = response.data
      let result403: any = null
      let resultData403 = _responseText
      result403 = JSON.parse(resultData403)
      return throwException(
        "Invalid card",
        status,
        _responseText,
        _headers,
        result403,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param body the credit card id
   * @return Successful Operation
   */
  updateDefaultCard(
    body: CardID,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateDefaultCard(_response)
      })
  }

  protected processUpdateDefaultCard(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid card id",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced from here https://stripe.com/docs/api/cards/object
   */
  getDefaultCard(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/default"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDefaultCard(_response)
      })
  }

  protected processGetDefaultCard(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the card
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  deleteCard(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteCard(_response)
      })
  }

  protected processDeleteCard(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "Invalid card id",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * put words here
   * @param id identification number of the card
   * @return Successful Operation, returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getCard(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/card/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetCard(_response)
      })
  }

  protected processGetCard(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "Card not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/cards/object
   */
  getAllCards(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/cards"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllCards(_response)
      })
  }

  protected processGetAllCards(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operations interacts with the 3rd Party Stripe API.
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/invoices/object
   */
  getAllInvoices(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/invoices"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllInvoices(_response)
      })
  }

  protected processGetAllInvoices(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @param id identification number of the subscription
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getSubscription(
    id: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscriptions{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSubscription(_response)
      })
  }

  protected processGetSubscription(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "subscription not found with requested id",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * This operation interacts with the 3rd Party Stripe API
   * @return Successful Operation returns objects referenced here https://stripe.com/docs/api/subscription/object
   */
  getAllSubscriptions(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/billing/subscriptions"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllSubscriptions(_response)
      })
  }

  protected processGetAllSubscriptions(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * upload a bunch of files to the pin service
   * @param file (optional)
   * @param path (optional)
   * @param replication (optional)
   * @param deal_duration (optional)
   * @return Successful Operation
   */
  uploadPins(
    file?: any | undefined,
    path?: string | undefined,
    replication?: number | undefined,
    deal_duration?: boolean | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.")
    else content_.append("file", file.toString())
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())
    if (replication === null || replication === undefined)
      throw new Error("The parameter 'replication' cannot be null.")
    else content_.append("replication", replication.toString())
    if (deal_duration === null || deal_duration === undefined)
      throw new Error("The parameter 'deal_duration' cannot be null.")
    else content_.append("deal_duration", deal_duration.toString())

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUploadPins(_response)
      })
  }

  protected processUploadPins(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authorization token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "Drive Service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "file store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * get pin object info
   * @param pin_id pin object cid
   * @return Successful Operation,
   */
  getPinsByCID(
    pin_id: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous2> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPinsByCID(_response)
      })
  }

  protected processGetPinsByCID(response: AxiosResponse): Promise<Anonymous2> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing authorization token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "no pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * delete the pin object
   * @param pin_id pin object cid
   * @return Successful Operation
   */
  deletePins(
    pin_id: string,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeletePins(_response)
      })
  }

  protected processDeletePins(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * modify a pin object
   * @param pin_id pin object cid
   * @param body information to update pin
   * @return Successful Operation
   */
  updatePin(
    pin_id: string,
    body: Body,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins/{pin_id}"
    if (pin_id === undefined || pin_id === null)
      throw new Error("The parameter 'pin_id' must be defined.")
    url_ = url_.replace("{pin_id}", encodeURIComponent("" + pin_id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdatePin(_response)
      })
  }

  protected processUpdatePin(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "No pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "No pin data was provider for modification",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * add pin objects
   * @param body words go here
   * @return Successful Operation
   */
  addPin(body: Body2, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/fps/pins"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddPin(_response)
      })
  }

  protected processAddPin(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "no pins with CID was found",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * list of pin objects
   * @param status (optional) filter pins by status
   * @param limit (optional) set a limit to the numbe of items returned
   * @param cid (optional) filter by storege id number
   * @param before (optional) filter by a date range
   * @param after (optional) filter by a date range
   * @return Successful Operation list of pinned objects
   */
  getAllPins(
    api_key: string,
    status?: Status | undefined,
    limit?: number | undefined,
    cid?: string | undefined,
    before?: string | undefined,
    after?: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous3[]> {
    let url_ = this.baseUrl + "/fps/pins?"
    if (status === null)
      throw new Error("The parameter 'status' cannot be null.")
    else if (status !== undefined)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    if (limit === null) throw new Error("The parameter 'limit' cannot be null.")
    else if (limit !== undefined)
      url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    if (cid === null) throw new Error("The parameter 'cid' cannot be null.")
    else if (cid !== undefined)
      url_ += "cid=" + encodeURIComponent("" + cid) + "&"
    if (before === null)
      throw new Error("The parameter 'before' cannot be null.")
    else if (before !== undefined)
      url_ += "before=" + encodeURIComponent("" + before) + "&"
    if (after === null) throw new Error("The parameter 'after' cannot be null.")
    else if (after !== undefined)
      url_ += "after=" + encodeURIComponent("" + after) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllPins(_response)
      })
  }

  protected processGetAllPins(response: AxiosResponse): Promise<Anonymous3[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "max limit of returned pin objects is 1000 and min is 1",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve asks
   * @return Successful Operation returns objects referenced here  https://github.com/textileio/powergate/blob/master/index/ask/types.go
   */
  getAsks(cancelToken?: CancelToken | undefined): Promise<Anonymous4> {
    let url_ = this.baseUrl + "/powergate/asks"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAsks(_response)
      })
  }

  protected processGetAsks(response: AxiosResponse): Promise<Anonymous4> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve deals
   * @param direction filter by deal type
   * @param only (optional) filter by deal status
   * @return Successful Operation returns a deal record object referenced here https://github.com/textileio/powergate/blob/master/deals/types.go
   */
  getDeals(
    direction: Direction,
    only?: Only | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous5> {
    let url_ = this.baseUrl + "/powergate/deals?"
    if (direction === undefined || direction === null)
      throw new Error(
        "The parameter 'direction' must be defined and cannot be null.",
      )
    else url_ += "direction=" + encodeURIComponent("" + direction) + "&"
    if (only === null) throw new Error("The parameter 'only' cannot be null.")
    else if (only !== undefined)
      url_ += "only=" + encodeURIComponent("" + only) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeals(_response)
      })
  }

  protected processGetDeals(response: AxiosResponse): Promise<Anonymous5> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer tokeng",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "no direction query parameter was provided in a request",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve faults
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/faults/types.go
   */
  getFaults(cancelToken?: CancelToken | undefined): Promise<Anonymous6> {
    let url_ = this.baseUrl + "/powergate/faults"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFaults(_response)
      })
  }

  protected processGetFaults(response: AxiosResponse): Promise<Anonymous6> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "no direction query parameter was provided in a request",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve miners
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getMiners(cancelToken?: CancelToken | undefined): Promise<Anonymous7> {
    let url_ = this.baseUrl + "/powergate/miners"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetMiners(_response)
      })
  }

  protected processGetMiners(response: AxiosResponse): Promise<Anonymous7> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve peers
   * @return Successful Operation returns objects referenced here hhttps://github.com/textileio/powergate/blob/master/net/interface.go
   */
  getPeers(cancelToken?: CancelToken | undefined): Promise<Anonymous8> {
    let url_ = this.baseUrl + "/powergate/peers"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "applicaiton/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPeers(_response)
      })
  }

  protected processGetPeers(response: AxiosResponse): Promise<Anonymous8> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve top miners by reputation
   * @param limit words go here
   * @return Successful Operation returns objects referenced here https://github.com/textileio/powergate/blob/master/index/miner/types.go
   */
  getTopMiners(
    api_key: string,
    limit: number,
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous9> {
    let url_ = this.baseUrl + "/powergate/reputation/topminers?"
    if (limit === undefined || limit === null)
      throw new Error(
        "The parameter 'limit' must be defined and cannot be null.",
      )
    else url_ += "limit=" + encodeURIComponent("" + limit) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        "api-key":
          api_key !== undefined && api_key !== null ? "" + api_key : "",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTopMiners(_response)
      })
  }

  protected processGetTopMiners(response: AxiosResponse): Promise<Anonymous9> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "invalid or missing bearer token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 429) {
      const _responseText = response.data
      let result429: any = null
      let resultData429 = _responseText
      result429 = JSON.parse(resultData429)
      return throwException(
        "provided limit is invalid",
        status,
        _responseText,
        _headers,
        result429,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * returns file store info
   * @return Successful Operation
   */
  getFileStoreInfo(
    cancelToken?: CancelToken | undefined,
  ): Promise<Anonymous10> {
    let url_ = this.baseUrl + "/drive/info"
    url_ = url_.replace(/[?&]$/, "")

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFileStoreInfo(_response)
      })
  }

  protected processGetFileStoreInfo(
    response: AxiosResponse,
  ): Promise<Anonymous10> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "File of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "Drive Service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve file content
   * @param body file path
   * @return Successful Operation
   */
  getFileContent(
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/download"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFileContent(_response)
      })
  }

  protected processGetFileContent(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File with such CID does not exists",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * uploads a file
   * @param file (optional)
   * @param path (optional)
   * @param type (optional)
   * @param update (optional)
   * @return Successful Operation
   */
  addFile(
    file?: FileParameter | undefined,
    path?: string | undefined,
    type?: string | undefined,
    update?: boolean | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/drive/upload"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = new FormData()
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.")
    else
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    if (path === null || path === undefined)
      throw new Error("The parameter 'path' cannot be null.")
    else content_.append("path", path.toString())
    if (type === null || type === undefined)
      throw new Error("The parameter 'type' cannot be null.")
    else content_.append("type", type.toString())
    if (update === null || update === undefined)
      throw new Error("The parameter 'update' cannot be null.")
    else content_.append("update", update.toString())

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddFile(_response)
      })
  }

  protected processAddFile(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * rename or move file to a new location in the heiarchy
   * @param body file path
   * @return Successful Operation
   */
  moveObject(
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/mv"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processMoveObject(_response)
      })
  }

  protected processMoveObject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid or missing Authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File Name do not exists for the provided user",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve all information available on a file
   * @param body file path
   * @return Successful Operation
   */
  getFileInfo(
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/file"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "GET",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFileInfo(_response)
      })
  }

  protected processGetFileInfo(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 400) {
      const _responseText = response.data
      let result400: any = null
      let resultData400 = _responseText
      result400 = JSON.parse(resultData400)
      return throwException(
        "File Store or File itself do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result400,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * removes a file or empty directory
   * @param body file path
   * @return Successful Operation
   */
  removeObject(
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/rm"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "GET",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRemoveObject(_response)
      })
  }

  protected processRemoveObject(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store or File do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * retrieve child list for provided directory path
   * @param body file path
   * @return Successful Operation
   */
  getChildList(
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileResponse[]> {
    let url_ = this.baseUrl + "/drive/files/ls"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetChildList(_response)
      })
  }

  protected processGetChildList(
    response: AxiosResponse,
  ): Promise<FileResponse[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data
      let result200: any = null
      let resultData200 = _responseText
      result200 = JSON.parse(resultData200)
      return result200
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }

  /**
   * creates new directory
   * @param body file path
   * @return Successful Operation
   */
  addDirectory(
    body: FileRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + "/drive/files/mkdir"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_)
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddDirectory(_response)
      })
  }

  protected processAddDirectory(response: AxiosResponse): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve<void>(<any>null)
    } else if (status === 401) {
      const _responseText = response.data
      return throwException(
        "Invalid authentication token",
        status,
        _responseText,
        _headers,
      )
    } else if (status === 503) {
      const _responseText = response.data
      let result503: any = null
      let resultData503 = _responseText
      result503 = JSON.parse(resultData503)
      return throwException(
        "drive service is not inilialized",
        status,
        _responseText,
        _headers,
        result503,
      )
    } else if (status === 404) {
      const _responseText = response.data
      let result404: any = null
      let resultData404 = _responseText
      result404 = JSON.parse(resultData404)
      return throwException(
        "File Store do not exists for the provided user identifier",
        status,
        _responseText,
        _headers,
        result404,
      )
    } else if (status === 409) {
      const _responseText = response.data
      let result409: any = null
      let resultData409 = _responseText
      result409 = JSON.parse(resultData409)
      return throwException(
        "file of directory name in conflict with existing structure",
        status,
        _responseText,
        _headers,
        result409,
      )
    } else {
      const _responseText = response.data
      let resultdefault: any = null
      let resultDatadefault = _responseText
      resultdefault = JSON.parse(resultDatadefault)
      return throwException(
        "server error",
        status,
        _responseText,
        _headers,
        resultdefault,
      )
    }
  }
}

export interface RPCRequest {
  /** version number */
  jsonrpc: string
  /** eth-rpc method */
  method: string
  /** params depends on rpc-method. Each rpc method has a different params */
  param?: any
  /** id of the rpc-call */
  id: number
}

export interface FileRequest {
  /** path to the file object */
  path: string
  /** used to change the destination of a request */
  source?: string
}

export interface FileResponse {
  /** cid in IPFS */
  cid?: string
  /** file name */
  name?: string
  /** size in bytes */
  size?: number
  /** content type */
  content_type?: string
}

export interface Login {
  /** Email Address of the user */
  email: string
  /** Password of the user */
  password: string
}

export interface Token {
  /** Authentication token used for api access */
  token: string
  /** The Expiration date of the token */
  expires: string
}

export interface AccessRefreshTokens {
  /** Authentication Token used for API access */
  access_token: Token
  /** Refresh Token used for API access */
  refresh_token: Token
}

export interface UserSignUp {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Password of the User */
  password: string
}

export interface UserPatch {
  /** First Name of the User */
  first_name: string
  /** Last Name of the User */
  last_name: string
  /** Email Address of the User */
  email: string
  /** UserName of the User */
  username?: string
  /** Phone Number of the User */
  phone?: string
  /** City of the User */
  city?: string
  /** Country of the User */
  country?: string
}

export interface User {
  /** Identification Number of the User */
  id?: number
  /** Timestamp of the User creation event */
  created_at?: string
  /** Timestamp of the last User last update */
  updated_at?: string
  /** Timestamp of the Users Delete event */
  deleted_at?: string
  /** The Universal Unique Identifier of the User */
  uuid?: string
  /** First Name of tne User */
  first_name?: string
  /** Last Name of the User */
  last_name?: string
  /** UserName of the User */
  username?: string
  /** Public Address of the User */
  public_address?: string
  /** Email Address of the User */
  email?: string
  /** Phone number of the User */
  phone?: string
  /** Is the User Active */
  active?: boolean
  /** Is the User Verified */
  verified?: boolean
  /** Is the User Payments Activated */
  payment_active?: boolean
  /** Timestamp of the Users last login */
  last_login?: string
  /** Timpstamp of the User's last password change */
  last_password_change?: string
  /** Timestamp of the User's last email change */
  last_email_change?: string
  /** IP address of the User's last login */
  login_ip?: string
  /** Timestamp of the last User login */
  login_at?: string
  /** Browser used by the User last */
  browser?: string
  /** City the User has registered */
  city?: string
  /** Country the User has registered */
  country?: string
}

export interface VerifyEmailToken {
  /** Identification Number of the User */
  id: number
  /** Authenticaton Token */
  token: string
}

export interface Web3Login {
  /** Token from the */
  token?: string
  expires?: string
}

export interface Web3RequestToken {
  /** Public Address of the user */
  public_address?: string
  /** Token gotten from calling the web3 login API */
  token: string
  /** Signature of the Token generated using user's Private Key */
  signature: string
}

export interface NewPassword {
  /** Current password of the user */
  old_password: string
  /** The password that will be set as current password */
  new_password: string
  /** Same as new_password */
  confirm_password?: string
}

export interface ResetPassword {
  /** the id that was sent in the email */
  id: number
  /** token sent in email */
  token: string
  /** New Password to be set for the User */
  password: string
  /** Same as password */
  password_confirm: string
}

export interface VerifyPasswordReset {
  /** id that was sent to email */
  id: number
  /** token sent in email */
  token: string
}

export interface ProjectRequest {
  /** Name of the Project and must be unique for a User */
  name: string
  /** Description of the project */
  description?: string
}

export interface Project {
  /** unique id of the project */
  id?: number
  /** creation time fo the Project */
  created_at?: string
  /** last time when project information was changed */
  updated_at?: string
  /** deleted_at is set when user deletes the project */
  deleted_at?: string
  /** name of the project */
  name?: string
  /** description of the project */
  description?: string
  /** status of the project. */
  status?: number
  /** user id for this project */
  user_id?: number
  /** redundant field */
  billing?: boolean
  /** api Key for this project */
  api_key?: string
  /** API Secret for this project */
  api_secret?: string
}

export interface NewDeploymentRequest {
  /** Project id for this deployment */
  project_id: number
  /** Currently eth (Ethereum) and etc (Ethereum classic) are supported */
  chain: string
  /** Type of blockchain network */
  network: NewDeploymentRequestNetwork
}

export interface Deployment {
  /** Unique id of the deployment */
  id?: number
  /** Creation time fo the deployment */
  created_at?: string
  /** Last time when deployment information was changed */
  updated_at?: string
  /** Deleted_at is set when user deletes the deployment */
  deleted_at?: string
  /** Name generated for this deployment */
  name?: string
  /** Type of the deployment */
  type?: string
  /** The specific software project eth (Ethereum) and etc (Ethereum classic) are supported */
  chain?: DeploymentChain
  /** For eth chain, mainnet, goerli, rinkeby, ropsten network are supported. And for etc chain, mainnet, kotti, mordor are supported. */
  network?: DeploymentNetwork
  /** Status of the deployment. CreationPending = 1, CREATING = 2, CREATED = 3, CreationFailed = 4, UpdatePending = 5, UPDATING= 6, UPDATED=7, UpdateFailed = 8, DeletionPending = 9, DELETING = 10, DELETED = 11, DeleteFailed = 12 */
  status?: number
  /** Project id for this deployment */
  project_id?: number
  /** User id for this deployment */
  user_id?: number
}

export interface AddCardRequest {
  /** card token returned from stripe */
  token: string
}

export interface CardID {
  /** id of the card that you want to perform an action on */
  id: number
}

export interface Body {
  /** words go here */
  pin?: Pin
  /** words go here */
  deal?: Deal
}

export interface Body2 {
  /** arrary of objects to be pinned */
  pin?: Pin2[]
  /** info about the deal */
  deal?: Deal2
}

export type Status = "queued" | "failed" | "pinning" | "pinned"

export type Direction = "retrieval" | "storage"

export type Only = "final" | "pending"

export interface Anonymous {
  /** The type or category of error */
  error_type?: string
  /** The error message */
  message?: string
}

export interface Anonymous2 {
  /** pin object identifier */
  id?: string
  /** date and time of pin object creation */
  create?: Date
  /** current status of pinned object */
  status?: Status2
  /** list of providers in which returned cid can be found */
  delegates?: string[]
  /** pin itself */
  pin?: Pin3
  /** words go here */
  deal?: Deal3
}

/** array of pin objects */
export interface Anonymous3 {
  /** pin object identifier */
  id?: string
  /** date and time of pin object creation */
  create?: Date
  /** current status of pinned object */
  status?: Status3
  /** list of providers in which returned cid can be found */
  delegates?: string[]
  /** pin itself */
  pin?: Pin4
}

export interface Anonymous4 {
  /** date last updated_at */
  lastupdated?: string
  /** storeage median price */
  storagemedianprice?: number
  /** information about the storage ask */
  storage?: any
}

export interface Anonymous5 {
  /** the deal record either type storage or retrieval */
  dealrecord?: string
}

export interface Anonymous6 {
  /** words go here */
  tipsetkey?: string
  /** words go here */
  miners?: any
}

export interface Anonymous7 {
  /** workds go here */
  meta?: any
  /** words go here */
  onchain?: any
}

export interface Anonymous8 {
  /** provides address info and location info about a peer */
  peerinfo?: any
}

/** miner info */
export interface Anonymous9 {
  /** miner's score */
  minerscore?: any
}

export interface Anonymous10 {
  /** FFs id */
  ffs_id?: string
  /** size of the File Store in bytes */
  size?: number
  /** size of the encrypted File Store in bytes */
  encrypted_size?: number
  /** wallet addresses */
  wallets?: string[]
  /** api key used for access */
  api_key?: string
}

export type NewDeploymentRequestNetwork =
  | "mainnet"
  | "goerli"
  | "rinkeby"
  | "kotti"
  | "mordor"

export type DeploymentChain = "eth" | "etc"

export type DeploymentNetwork =
  | "mainnet"
  | "goerlio"
  | "rinkeby"
  | "ropsten"
  | "kotti"
  | "mordor"

export interface Pin {
  /** file cid */
  cid?: string
}

export interface Deal {
  /** words go here */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export interface Pin2 {
  /** file identification number */
  cid?: string
  /** list of hint-providers for the pin */
  providers?: string[]
}

export interface Deal2 {
  /** length of the deal */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export type Status2 = "queued" | "pinning" | "pinned" | "failed"

export interface Pin3 {
  /** file identification number */
  cid?: string
  /** list of providers hints provided by user on the time of pinning */
  origins?: string[]
}

export interface Deal3 {
  /** words go here */
  deal_duration?: number
  /** words go here */
  replication?: number
}

export type Status3 = "queued" | "pinning" | "pinned" | "failed"

export interface Pin4 {
  /** file identification number */
  cid?: string
  /** list of providers hints provided by user on the time of pinning */
  origins?: string[]
}

export interface FileParameter {
  data: any
  fileName: string
}

export class ImployApiException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isImployApiException = true

  static isImployApiException(obj: any): obj is ImployApiException {
    return obj.isImployApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result
  else throw new ImployApiException(message, status, response, headers, null)
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true
}

/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
export class IConfig {
  /**
   * Returns a valid value for the Authorization header.
   * Used to dynamically inject the current auth header.
   */
}
